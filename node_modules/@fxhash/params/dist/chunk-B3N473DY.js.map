{"version":3,"sources":["../src/utils.ts"],"names":["hex"],"mappings":"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","file":"chunk-B3N473DY.js","sourcesContent":["import {\n  hexString,\n  FxParamDefinition,\n  FxParamProcessor,\n  FxParamProcessors,\n  FxParamTypeMap,\n  FxParamType,\n  FxParamsData,\n  FxParamValue,\n  FxParamTranformType,\n  FxParamProcessorTransformer,\n  FxParamTransformation,\n  FxParamsRaw,\n  FxParamsTransformed,\n  FxParamDefinitions,\n} from \"./types\"\n\nexport function rgbaToHex(r: number, g: number, b: number, a: number): string {\n  const outParts = [\n    r.toString(16),\n    g.toString(16),\n    b.toString(16),\n    Math.round(a * 255)\n      .toString(16)\n      .substring(0, 2),\n  ]\n\n  // Pad single-digit output values\n  outParts.forEach(function (part, i) {\n    if (part.length === 1) {\n      outParts[i] = \"0\" + part\n    }\n  })\n\n  return \"#\" + outParts.join(\"\")\n}\n\nfunction completeHexColor(hexCode: hexString | string): string {\n  let hex = hexCode.replace(\"#\", \"\")\n  if (hex.length === 6) {\n    hex = `${hex}ff`\n  }\n  if (hex.length === 3) {\n    hex = `${hex[0]}${hex[0]}${hex[1]}${hex[1]}${hex[2]}${hex[2]}ff`\n  }\n  return hex\n}\n\nexport function hexToRgba(hexCode: hexString) {\n  const hex = completeHexColor(hexCode)\n\n  const r = parseInt(hex.substring(0, 2), 16)\n  const g = parseInt(hex.substring(2, 4), 16)\n  const b = parseInt(hex.substring(4, 6), 16)\n  const a =\n    Math.round(\n      (parseInt(hex.substring(6, 8), 16) / 255 + Number.EPSILON) * 100\n    ) / 100\n\n  return { r, g, b, a }\n}\n\nconst stringToHex = function (s: string) {\n  let rtn = \"\"\n  for (let i = 0; i < s.length; i++) {\n    rtn += s.charCodeAt(i).toString(16).padStart(4, \"0\")\n  }\n  return rtn\n}\nconst hexToString = function (h: string) {\n  const hx = h.match(/.{1,4}/g) || []\n  let rtn = \"\"\n  for (let i = 0; i < hx.length; i++) {\n    const int = parseInt(hx[i], 16)\n    if (int === 0) break\n    rtn += String.fromCharCode(int)\n  }\n  return rtn\n}\n\nexport const MIN_SAFE_INT64 = BigInt(\"-9223372036854775808\")\nexport const MAX_SAFE_INT64 = BigInt(\"9223372036854775807\")\n\nexport const ParameterProcessors: FxParamProcessors = {\n  number: {\n    serialize: input => {\n      const view = new DataView(new ArrayBuffer(8))\n      view.setFloat64(0, input)\n      return view.getBigUint64(0).toString(16).padStart(16, \"0\")\n    },\n    deserialize: input => {\n      const view = new DataView(new ArrayBuffer(8))\n      for (let i = 0; i < 8; i++) {\n        view.setUint8(i, parseInt(input.substring(i * 2, i * 2 + 2), 16))\n      }\n      return view.getFloat64(0)\n    },\n    bytesLength: () => 8,\n    constrain: (value, definition) => {\n      let min = Number.MIN_SAFE_INTEGER\n      if (typeof definition.options?.min !== \"undefined\")\n        min = Number(definition.options.min)\n      let max = Number.MAX_SAFE_INTEGER\n      if (typeof definition.options?.max !== \"undefined\")\n        max = Number(definition.options.max)\n      max = Math.min(max, Number.MAX_SAFE_INTEGER)\n      min = Math.max(min, Number.MIN_SAFE_INTEGER)\n      const v = Math.min(Math.max(value, min), max)\n      if (definition?.options?.step) {\n        const t = 1.0 / definition?.options?.step\n        return Math.round(v * t) / t\n      }\n      return v\n    },\n    random: definition => {\n      let min = Number.MIN_SAFE_INTEGER\n      if (typeof definition.options?.min !== \"undefined\")\n        min = Number(definition.options.min)\n      let max = Number.MAX_SAFE_INTEGER\n      if (typeof definition.options?.max !== \"undefined\")\n        max = Number(definition.options.max)\n      max = Math.min(max, Number.MAX_SAFE_INTEGER)\n      min = Math.max(min, Number.MIN_SAFE_INTEGER)\n      const v = Math.random() * (max - min) + min\n      if (definition?.options?.step) {\n        const t = 1.0 / definition?.options?.step\n        return Math.round(v * t) / t\n      }\n      return v\n    },\n  },\n  bigint: {\n    serialize: (input: any) => {\n      const view = new DataView(new ArrayBuffer(8))\n      view.setBigInt64(0, BigInt(input))\n      return view.getBigUint64(0).toString(16).padStart(16, \"0\")\n    },\n    deserialize: (input: any) => {\n      const view = new DataView(new ArrayBuffer(8))\n      for (let i = 0; i < 8; i++) {\n        view.setUint8(i, parseInt(input.substring(i * 2, i * 2 + 2), 16))\n      }\n      return view.getBigInt64(0)\n    },\n    bytesLength: () => 8,\n    random: definition => {\n      let min = MIN_SAFE_INT64\n      let max = MAX_SAFE_INT64\n      if (typeof definition.options?.min !== \"undefined\")\n        min = BigInt(definition.options.min)\n      if (typeof definition.options?.max !== \"undefined\")\n        max = BigInt(definition.options.max)\n      const range = max - min\n      const bits = range.toString(2).length\n      let random\n      do {\n        random = BigInt(\n          \"0b\" +\n            Array.from(\n              crypto.getRandomValues(new Uint8Array(Math.ceil(bits / 8)))\n            )\n              .map(b => b.toString(2).padStart(8, \"0\"))\n              .join(\"\")\n        )\n      } while (random > range)\n      return random + min\n    },\n  },\n  boolean: {\n    serialize: input => {\n      return typeof input === \"boolean\"\n        ? input\n          ? \"01\"\n          : \"00\"\n        : typeof input === \"string\"\n          ? input === \"true\"\n            ? \"01\"\n            : \"00\"\n          : \"00\"\n    },\n    deserialize: input => {\n      return input === \"00\" ? false : true\n    },\n    bytesLength: () => 1,\n    random: () => Math.random() < 0.5,\n  },\n\n  color: {\n    serialize: (input: string) => {\n      return completeHexColor(input)\n    },\n\n    deserialize: (input): hexString => {\n      return input as hexString\n    },\n    bytesLength: () => 4,\n    transform: (input: string) => {\n      const color = completeHexColor(input)\n      const r = parseInt(color.slice(0, 2), 16)\n      const g = parseInt(color.slice(2, 4), 16)\n      const b = parseInt(color.slice(4, 6), 16)\n      const a = parseInt(color.slice(6, 8), 16)\n      return {\n        hex: {\n          rgb: \"#\" + input.slice(0, 6),\n          rgba: \"#\" + input,\n        },\n        obj: {\n          rgb: { r, g, b },\n          rgba: { r, g, b, a },\n        },\n        arr: {\n          rgb: [r, g, b],\n          rgba: [r, g, b, a],\n        },\n      }\n    },\n    constrain: value => {\n      const hex = value.replace(\"#\", \"\")\n      return hex.slice(0, 8).padEnd(8, \"f\")\n    },\n    random: () =>\n      `${[...Array(8)]\n        .map(() => Math.floor(Math.random() * 16).toString(16))\n        .join(\"\")}`,\n  },\n\n  string: {\n    serialize: (input, def) => {\n      if (!def.version) {\n        let hex = stringToHex(input.substring(0, 64))\n        hex = hex.padEnd(64 * 4, \"0\")\n        return hex\n      }\n      let max = 64\n      if (typeof def.options?.maxLength !== \"undefined\")\n        max = Number(def.options.maxLength)\n      let hex = stringToHex(input.substring(0, max))\n      hex = hex.padEnd(max * 4, \"0\")\n      return hex\n    },\n    deserialize: input => {\n      return hexToString(input)\n    },\n\n    bytesLength: def => {\n      if (!def.version) {\n        return 64 * 2\n      }\n      if (typeof def.options?.maxLength !== \"undefined\")\n        return Number(def.options.maxLength) * 2\n      return 64 * 2\n    },\n    random: definition => {\n      let min = 0\n      if (typeof definition.options?.minLength !== \"undefined\")\n        min = definition.options.minLength\n      let max = 64\n      if (typeof definition.options?.maxLength !== \"undefined\")\n        max = definition.options.maxLength\n      const length = Math.round(Math.random() * (max - min) + min)\n      return [...Array(length)]\n        .map(i => (~~(Math.random() * 36)).toString(36))\n        .join(\"\")\n    },\n    constrain: (value, definition) => {\n      let min = 0\n      if (typeof definition.options?.minLength !== \"undefined\")\n        min = definition.options.minLength\n      let max = 64\n      if (typeof definition.options?.maxLength !== \"undefined\")\n        max = definition.options.maxLength\n      const v = value.slice(0, max)\n      if (v.length < min) {\n        return v.padEnd(min)\n      }\n      return v\n    },\n  },\n\n  bytes: {\n    serialize: (input, def) => {\n      return Array.from(input)\n        .map(i => i.toString(16).padStart(2, \"0\"))\n        .join(\"\")\n    },\n    deserialize: (input, def) => {\n      const len = input.length / 2\n      const uint8 = new Uint8Array(len)\n      let idx\n      for (let i = 0; i < len; i++) {\n        idx = i * 2\n        uint8[i] = parseInt(`${input[idx]}${input[idx + 1]}`, 16)\n      }\n      return uint8\n    },\n    bytesLength: def => def.options.length,\n    random: def => {\n      const len = def.options?.length || 0\n      const uint8 = new Uint8Array(len)\n      for (let i = 0; i < len; i++) {\n        uint8[i] = (Math.random() * 255) | 0\n      }\n      return uint8\n    },\n  },\n\n  select: {\n    serialize: (input, def) => {\n      // find the index of the input in the array of options\n      return Math.min(255, def.options?.options?.indexOf(input) || 0)\n        .toString(16)\n        .padStart(2, \"0\")\n    },\n\n    deserialize: (input, def) => {\n      // get the index, which is the input\n      const idx = parseInt(input, 16)\n      return def.options?.options?.[idx] || def.options?.options?.[0] || \"\"\n    },\n\n    bytesLength: () => 1, // index between 0 and 255\n    constrain: (value, definition) => {\n      if (definition.options.options.includes(value)) {\n        return value\n      }\n      return definition.options.options[0]\n    },\n    random: definition => {\n      const index = Math.round(\n        Math.random() * (definition.options.options.length - 1) + 0\n      )\n      return definition?.options?.options[index]\n    },\n  },\n}\n\n// params are injected into the piece using the binary representation of the\n// numbers, to keep precision\nexport function serializeParams(\n  params: any,\n  definition: FxParamDefinition<any>[]\n) {\n  // a single hex string will be used for all the params\n  let bytes = \"\"\n  if (!definition) return bytes\n  // loop through each parameter from the definition to find the associated\n  // parameter as set on the UI\n  for (const def of definition) {\n    const { id, type } = def\n    const processor = ParameterProcessors[\n      type as FxParamType\n    ] as FxParamProcessor<any>\n    // if the param is definined in the object\n\n    const v = params[id] as FxParamTypeMap[]\n    const val =\n      typeof v !== \"undefined\"\n        ? v\n        : typeof def.default !== \"undefined\"\n          ? def.default\n          : processor.random(def)\n    const serialized = processor.serialize(val, def)\n    bytes += serialized\n  }\n\n  return bytes\n}\n\n// call seralizeParams(), returns nullif no params\nexport function serializeParamsOrNull(\n  params: FxParamsData,\n  definition: FxParamDefinition<any>[]\n) {\n  const serialized = serializeParams(params, definition || [])\n  if (serialized.length === 0) return null\n  return serialized\n}\n\n// takes an array of bytes, in hexadecimal format, and a parametric space\n// definition and outputs an array of parameters, mapping the definition and\n// validating input based on the definition constraints\nexport function deserializeParams(\n  bytes: string,\n  definition: FxParamDefinition<FxParamType>[],\n  options: { withTransform?: boolean; transformType?: FxParamTranformType }\n) {\n  const params: FxParamsRaw | FxParamsTransformed = {}\n  for (const def of definition) {\n    const processor = ParameterProcessors[\n      def.type as FxParamType\n    ] as FxParamProcessor<FxParamType>\n    const transformer =\n      options.withTransform &&\n      (processor[\n        options.transformType || \"transform\"\n      ] as FxParamProcessorTransformer<FxParamType>)\n    if (!bytes) {\n      let v\n      if (typeof def.default === \"undefined\") v = processor.random(def)\n      else v = def.default\n      params[def.id] = transformer ? transformer(v, def) : v\n      continue\n    }\n    // extract the length from the bytes & shift the initial bytes string\n    const bytesLen = processor.bytesLength(def)\n    const valueBytes = bytes.substring(0, bytesLen * 2)\n    bytes = bytes.substring(bytesLen * 2)\n    // deserialize the bytes into the params\n    const val = processor.deserialize(\n      valueBytes,\n      def\n    ) as FxParamValue<FxParamType>\n    params[def.id] = transformer ? transformer(val, def) : val\n  }\n  return params\n}\n\n// Consolidates parameters from both a params object provided by the token\n// and the dat object of params, which is stored by the controls component.\nexport function consolidateParams(params: any, data: any) {\n  if (!params) return []\n\n  const rtn = [...params]\n\n  for (const p in rtn) {\n    const definition = rtn[p]\n    const { id, type, default: def } = definition\n    if (data && data.hasOwnProperty(id)) {\n      rtn[p].value = data[id]\n    } else {\n      const processor = ParameterProcessors[\n        type as FxParamType\n      ] as FxParamProcessor<any>\n      let v\n      if (typeof def === \"undefined\") v = processor.random(definition)\n      else v = def\n      rtn[p].value = processor.transform?.(v) || v\n    }\n  }\n\n  return rtn\n}\n\n/**\n * Given a definition and some params data, builds a clean params object where\n * the values are first found in the data object, then in the definition if a\n * default value exists, otherwise in randomizes the value using the param\n * associated processor.\n *\n * @param definition an array of parameter definition\n * @param data the params data used to reconstruct the final values\n */\nexport function buildParamsObject(\n  definition: FxParamDefinitions,\n  data: FxParamsData | null\n) {\n  if (!definition) return {}\n\n  const out: FxParamsData = {}\n  for (const def of definition) {\n    // find if the data object has the propery\n    if (data?.hasOwnProperty(def.id)) {\n      out[def.id] = data[def.id]\n      continue\n    }\n    // find if the definition object has a default value\n    if (def.hasOwnProperty(\"default\")) {\n      out[def.id] = def.default\n      continue\n    }\n    // otherwise use the param processor randomizer\n    const processor = ParameterProcessors[def.type] as FxParamProcessor<any>\n    const rand = processor.random(def)\n    out[def.id] = processor.transform?.(rand) || rand\n  }\n  return out\n}\n\nexport function getRandomParamValues(\n  params: FxParamDefinition<FxParamType>[],\n  options?: { noTransform?: boolean; randomizeAll?: boolean }\n): any {\n  return params.reduce(\n    (acc, definition) => {\n      const processor = ParameterProcessors[\n        definition.type as FxParamType\n      ] as FxParamProcessor<FxParamType>\n      let v = (definition.value || definition.default) as FxParamType\n      if (definition.update !== \"code-driven\" || options?.randomizeAll) {\n        v = processor.random(definition) as FxParamType\n      }\n      if (v) {\n        acc[definition.id] = options?.noTransform\n          ? v\n          : processor.transform?.(v) || v\n      }\n      return acc\n    },\n    {} as Record<string, any>\n  )\n}\n\nexport function sumBytesParams(\n  definitions: FxParamDefinition<FxParamType>[]\n): number {\n  return (\n    definitions?.reduce(\n      (acc, def) =>\n        acc +\n        (\n          ParameterProcessors[\n            def.type as FxParamType\n          ] as FxParamProcessor<FxParamType>\n        ).bytesLength(def),\n      0\n    ) || 0\n  )\n}\n\nexport function stringifyParamsData(data: FxParamsData) {\n  return JSON.stringify(data, (key, value) => {\n    if (typeof value === \"bigint\") return value.toString()\n    return value\n  })\n}\n\nexport function jsonStringifyBigint(data: any): string {\n  return JSON.stringify(data, (key, value) => {\n    if (typeof value === \"bigint\") return value.toString()\n    return value\n  })\n}\n\nexport const processParam = (\n  paramId: string,\n  value: FxParamValue<FxParamType>,\n  definitions: FxParamDefinition<FxParamType>[],\n  transformType: FxParamTranformType\n): FxParamValue<FxParamType> | FxParamTransformation => {\n  const definition = definitions.find(d => d.id === paramId)\n  if (!definition) {\n    throw new Error(`No definition found for param ${paramId}`)\n  }\n  const processor = ParameterProcessors[definition.type]\n  const transformer = processor[\n    transformType\n  ] as FxParamProcessorTransformer<FxParamType>\n  return transformer?.(value, definition) || value\n}\n\nexport const processParams = (\n  values: FxParamsData,\n  definitions: FxParamDefinition<FxParamType>[],\n  transformType: FxParamTranformType\n): Record<string, FxParamValue<FxParamType>> => {\n  const paramValues: Record<string, FxParamValue<FxParamType>> = {}\n  for (const definition of definitions) {\n    const processor = ParameterProcessors[definition.type]\n    const value = values[definition.id]\n    // deserialize the bytes into the params\n    const transformer = processor[\n      transformType\n    ] as FxParamProcessorTransformer<FxParamType>\n    paramValues[definition.id] = transformer?.(value, definition) || value\n  }\n  return paramValues\n}\n"]}