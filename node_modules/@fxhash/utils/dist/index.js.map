{"version":3,"file":"index.js","names":["hex: string","str: string","serializable: any","uint8: Uint8Array","str: string","length: number","ellipsis: string","index: number","byteArray: number[]","condition: unknown","message: string","value: T","error: E","value: any","result: Result<T, IEquatableError>","result: Result<T, E>","obj: O","array: T[]","par2: T | ((item: T) => boolean)","arr: T[]","test: (item: T) => boolean","isSame: TArrayCompareFn<T>","arrayCopy: TArrayCopyFn<T>","transformSplitsEqual: TSplitsTransformer","transformSplitsSum1000: TSplitsTransformer","transformSplitsSum100: TSplitsTransformer","transformSplitsAccessList: TSplitsTransformer","name: K","fn: EventReceiver<T[K]>","listeners: EventReceiver<T[K]>[]","emitter: EventEmitter<T>","event: EventKey<T>","muted: boolean","_toClean: Cleaner[]","state: Init","failReason: InitializationError<Err> | undefined","reason: Err","message?: string","cause?: Reason","init: Initialization","fn: () => Promise<void>","err: any","x: T","fn: (...params: FnParams) => Promise<FnReturn>","options: IRetryOptions<FnReturn>","fn: () => Promise<FnReturn>","start: number","fnError: any","ms: number","fn: IntervalFn","generator: (...args: U) => T","warning?: string","instance: T | null","url: string","maxRetries: number","delay: number","shouldStop: StopConditionType","timeout: number | false","error: any","options: FetchOptions","n: number","i: number","operation: () => Promise<T>","options: RetryOptions"],"sources":["../src/base58.ts","../src/bytes.ts","../src/uint8.ts","../src/string.ts","../src/types/errors.ts","../src/types/result.ts","../src/types/enums.ts","../src/array.ts","../src/splits.ts","../src/events.ts","../src/control-flows/cleanup.ts","../src/control-flows/initialization.ts","../src/control-flows/nullish.ts","../src/control-flows/retry.ts","../src/control-flows/sleep.ts","../src/control-flows/timeout.ts","../src/functions.ts","../src/fetch.ts","../src/float.ts","../src/network.ts"],"sourcesContent":["import bs58check from \"bs58check\"\n\n/**\n * OP_PREFIX: Tezos operation prefix\n * 5 (0x05) represents the generic operation tag\n * 116 (0x74) is the operation kind tag for transactions\n * This prefix is used to identify Tezos operations in the network\n */\nconst OP_PREFIX = new Uint8Array([5, 116])\n\n/**\n * Encodes a 32 bytes hex string with base58check, and pads the output with\n * an initial information byte \"o\", just like Tezos operations.\n * @param hex input 32 bytes hex string to encode\n */\nexport function b58checkHexString(hex: string): string {\n  // Remove '0x' prefix if present\n  const cleanHex = hex.startsWith(\"0x\") ? hex.slice(2) : hex\n\n  // Convert hex string to Uint8Array\n  const hexBuffer = new Uint8Array(\n    cleanHex.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16))\n  )\n\n  // Concatenate OP_PREFIX with the hex buffer\n  const fullBuffer = new Uint8Array(OP_PREFIX.length + hexBuffer.length)\n  fullBuffer.set(OP_PREFIX)\n  fullBuffer.set(hexBuffer, OP_PREFIX.length)\n\n  // Encode using bs58check\n  const encoded = bs58check.encode(fullBuffer)\n\n  // Prefix with 'o' as per Tezos operations\n  return \"o\" + encoded\n}\n","/**\n * Very quick string hashing algorithm where each character is passed through\n * some xorshift variant to produce some 64bit hash represented as a number.\n * Can be useful when there is a need to derive some unique ID for unique\n * strings in a fast way.\n *\n * @param str A string as input\n *\n * @returns A hash as a 64bit number for faster processing\n *\n * @example\n * ```ts\n * const hash = xorshiftString(\"hello world\") // 7d2fb77d\n * const hash = xorshiftString(\"hey\")          // 216e3ffa\n * const hash = xorshiftString(\"a\")            // 704e3821\n * const hash = xorshiftString(\"b\")            // 4e37a71e\n * ```\n */\nexport function xorshiftString(str: string): number {\n  let x = 0x0\n  for (let i = 0; i < str.length; i++) {\n    const c = str.charCodeAt(i)\n    x ^= c\n    x ^= x << 13\n    x ^= x >> 7\n    x ^= x << 17\n  }\n  return x\n}\n\n/**\n * Computes a 64bit hash (returned as a number) for any serializable value\n * passed. The value must be serializable using `JSON.stringify()` otherwise\n * this function throws.\n *\n * Under the hood, does `xorshiftString(JSON.stringify(serializable))`\n *\n * @param serializable A value which can be serialized with `JSON.stringify()`\n *\n * @returns A 64bit hash as a number\n *\n * @example\n * ```ts\n * const hash = xorshift64({ some: \"value\", numb: 2 }) // 7e34a2b7\n * ```\n */\nexport function xorshift64(serializable: any): number {\n  return xorshiftString(JSON.stringify(serializable))\n}\n","/**\n * Outputs the lowercase hex string representation of a Uint8Array\n * @param uint8 A sequence of bytes to convert\n * @returns The lowercase hex string representation of the Uint8Array\n *\n * @example\n *\n * const arr = new Uint8Array(255, 0, 128, 0, 128, 255)\n * const hex = uint8(arr) // \"ff00800080ff\"\n */\nexport function u8hex(uint8: Uint8Array): string {\n  return [...uint8].map(x => x.toString(16).padStart(2, \"0\")).join(\"\")\n}\n","/**\n * Turn the first character of a string into an UPPERCASE letter.\n * @param str String to capitalize\n * @returns Capitalized string\n *\n * @example\n *\n * capitalize(\"abcde\") // \"Abcde\"\n */\nexport function capitalize(str: string): string {\n  if (!str) return \"\"\n  return str.charAt(0).toUpperCase() + str.slice(1)\n}\n\nexport function truncateMiddle(\n  str: string,\n  length: number,\n  ellipsis: string = \"...\"\n): string {\n  if (length * 2 >= str.length) {\n    return str\n  }\n\n  const start = str.slice(0, length)\n  const end = str.slice(-length)\n\n  return `${start}${ellipsis}${end}`\n}\n\n/**\n * Generates a *unique* string ID, using `Date.now()` and `Math.random()`. IDs\n * may not have the same length.\n *\n * **Warning: not cryptographically secure!**\n *\n * @returns A *unique* string ID\n */\nexport function uniqueId(): string {\n  return Date.now().toString(36) + Math.random().toString(36).slice(2)\n}\n\n/**\n * Splits a string in 2 sections at a given index, and returns these 2 sections.\n */\nexport function splitStringAt(str: string, index: number): [string, string] {\n  return [str.slice(0, index), str.slice(index)]\n}\n/**\n * convert a string of tags separated by commas into an array of tags\n * @param str String of tags separated by commas\n * @returns Array\\<string> of tags\n */\nexport function tagsFromString(str: string): string[] {\n  return str\n    .split(\",\")\n    .map(tag => tag.trim())\n    .filter(tag => tag.length > 0)\n}\n\n/**\n * convert an array of bytes into a string\n * @param byteArray Array of numbers to\n * @returns String\n */\n\nexport function bytesToString(byteArray: number[]): string {\n  return Array.from(byteArray, function (byte) {\n    return (\"0\" + (byte & 0xff).toString(16)).slice(-2)\n  }).join(\"\")\n}\n\n/**\n * convert string to byte string\n * @param str String to convert\n * @returns Byte string\n */\n\nexport function stringToByteString(str: string): string {\n  const bytes = []\n  for (let i = 0; i < str.length; i++) {\n    bytes.push(str.charCodeAt(i))\n  }\n  return bytesToString(bytes)\n}\n","/**\n * An error that occurs when a task violates a logical condition that is assumed to be true at all times.\n */\nexport class InvariantError extends Error {\n  name = \"InvariantError\" as const\n}\n\n/**\n * Asserts that the given condition is truthy\n *\n * @param condition - Either truthy or falsy value\n * @param message - An error message\n */\nexport function invariant(\n  condition: unknown,\n  message: string\n): asserts condition {\n  if (!condition) {\n    throw new InvariantError(message)\n  }\n}\n","// Logic imported from the Lens SDK\n// https://github.com/lens-protocol/lens-sdk/blob/lens-v2/packages/shared-kernel/src/Result.ts\nimport { invariant } from \"./errors\"\n\ntype Primitive = string | number | boolean | bigint | symbol | undefined | null\n\ntype Cast<A, B> = A extends B ? A : B\n\ntype Narrow<A> = Cast<\n  A,\n  [] | (A extends Primitive ? A : never) | { [K in keyof A]: Narrow<A[K]> }\n>\n\n/**\n * A `Success<T, E>` represents a successful computation that returns a value of type `T`.\n *\n * `E` in `Success<T, E>` is the type of the error that would have been returned in case of failure.\n * It's present only to allow type safety of the `isFailure` method.\n *\n * @sealed\n * @privateRemarks DO NOT EXPORT, see type export later on\n * @typeParam T - the success value type\n */\nclass Success<T> {\n  /** @internal */\n  public constructor(public readonly value: T) {}\n\n  public isSuccess(): this is Success<T> {\n    return true\n  }\n\n  public isFailure(): this is Failure<unknown> {\n    return false\n  }\n\n  unwrap(): T {\n    return this.value\n  }\n}\n\n/**\n * A `Success<T, E>` represents a successful computation that returns a value of type `T`.\n *\n * `T` in `Failure<T, E>` is the type of the value that would have been returned in case of success.\n * It's present only to allow type safety of the `isSuccess` method.\n *\n * @sealed\n * @privateRemarks DO NOT EXPORT, see type export later on\n * @typeParam E - the failure error type\n */\nclass Failure<E> {\n  /** @internal */\n  public constructor(public readonly error: E) {}\n\n  public isSuccess(): this is Success<unknown> {\n    return false\n  }\n\n  public isFailure(): this is Failure<E> {\n    return true\n  }\n\n  unwrap(): never {\n    throw this.error\n  }\n}\n\nexport { Success, Failure }\n\n/**\n * An `IEquatableError` is an error that can be compared by name.\n *\n */\nexport interface IEquatableError<T extends string = string, P = Narrow<T>> {\n  name: P\n}\n\n/**\n * A `Result` type represents either `Success` or `Failure`.\n *\n * **TL;DR**\n *\n * `Result` is a minimalist implementation of a value that can be a \"success\" or a \"failure\".\n * It borrows from what done in other modern languages (i.e. Rust, Kotlin, Swift, etc.).\n *\n * The Lens SDK adopts this pattern in order to:\n * - be explicit about the known failure scenarios of a task,\n * - provide a way for consumers to perform exhaustive error handling,\n * - makes control flow easier to reason about.\n *\n * @remarks\n *\n * You might be familiar with the `Either` type from functional programming. The `Result` type\n * could be seen as a more specific version of `Either` where the left side is reserved for\n * success scenarios and the right side is reserved for known failure scenarios.\n *\n * Think of failure scenarios as alternative outcomes of a given task that although not the \"happy path\",\n * are still legitimate results for the task within the boundary of a correct usage of the SDK.\n *\n * In promoting exhaustive error handling, the Lens SDK makes it easier to evolve your code\n * when a new error case is added or a case is removed.\n * For example after a Lens SDK upgrade you can simply run the TS compiler to figure out where you\n * need to handle the new error cases, or even better, it guides you to remove obsolescent code\n * where an error case is no longer possible. This is virtually impossible with a `try/catch` approach.\n *\n * Thrown exceptions are historically difficult to trace. They require implicit knowledge\n * of the implementation details of the code that might throw exceptions. This might go several\n * layers down and leads to tight coupling between modules.\n *\n * The Lens SDK still throws exceptions where the error is not a \"normal execution scenario\".\n * These are considered real \"exceptional circumstances\" and not alternative outcomes and it's up to the consumer to `try/catch` them.\n *\n * An example of errors that are thrown by the SDK is {@link InvariantError}. They are often thrown as result of a misuse of the SDK.\n * By throwing them we want to fail fast so the consumer can fix the issue as soon as possible.\n * Specifically for `InvariantError`, there is no need to code defensively against these errors. Just rectify the coding issue and move on.\n *\n * @example\n * Control flow\n * ```ts\n * const result: Result<number, RangeError> = doSomething();\n *\n * if (result.isFailure()) {\n *   // because of the `isFailure` check above, TS knows that `result` is a `Failure<RangeError>` here\n *   console.log(result.error); // result.error gets narrowed to `RangeError`\n *\n *   return; // early return\n * }\n *\n * // because of the `isFailure` check above and the early return, TS knows that `result` is a `Success<number>` here\n * console.log(result.value); // result.value gets narrowed to `number`\n * ```\n *\n * @example\n * Exhaustive error handling\n *\n * Given a result type like the following:\n *\n * ```ts\n * const result: Result<number, PendingSigningError | WalletConnectionError> = doSomething();\n * ```\n * You can use a function with a `switch` statement to perform exhaustive error handling:\n * ```ts\n * function format(failure: Failure<PendingSigningError | WalletConnectionError>): string {\n *   switch (failure.error.name) {\n *     case 'PendingSigningError':\n *       return 'Please sign the transaction';\n *       break;\n *     case 'WalletConnectionError':\n *       return 'Please connect your wallet and try again';\n *       break;\n *   }\n *   // any code after the switch statement is unreachable\n * }\n * ```\n * The example above assumes `allowUnreachableCode: false` in your `tsconfig.json`.\n *\n * An even more robust way to perform exhaustive error handling with a `switch` is to use the `never` type: see {@link https://www.typescriptlang.org/docs/handbook/2/narrowing.html#exhaustiveness-checking | exhaustiveness checking}.\n *\n * @see https://wiki.c2.com/?AvoidExceptionsWheneverPossible\n * @see https://developer.apple.com/documentation/swift/result\n * @see https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-result/\n * @see https://the-guild.dev/blog/graphql-error-handling-with-fp#monads-to-the-rescue\n *\n * @typeParam T - the success value type\n * @typeParam E - the failure error type\n */\nexport type Result<T, E extends IEquatableError> = Success<T> | Failure<E>\n\n/**\n * A `PromiseResult` is a convenience type alias that represents either a {@link Result} in the context of asynchronous tasks.\n *\n * @typeParam T - the success value type\n * @typeParam E - the failure error type\n */\nexport type PromiseResult<T, E extends IEquatableError> = Promise<Result<T, E>>\n\n/**\n * @internal\n */\nexport function success(): Success<void>\nexport function success<T>(value: T): Success<T>\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function success<T>(value: any = undefined): Success<T> {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  return new Success(value)\n}\n\n/**\n * @internal\n */\nexport const failure = <E extends IEquatableError>(error: E): Failure<E> =>\n  new Failure(error)\n\n/**\n * Ensures the `Result<T, E>` is a `Success<T>`.\n */\nexport function assertSuccess<T>(\n  result: Result<T, IEquatableError>\n): asserts result is Success<T> {\n  invariant(result.isSuccess(), \"Expected a success result\")\n}\n\n/**\n * Ensures the `Result<T, E>` is a `Failure<E>`.\n */\nexport function assertFailure<T, E extends IEquatableError>(\n  result: Result<T, E>\n): asserts result is Failure<E> {\n  invariant(result.isFailure(), \"Expected a failure result\")\n}\n","/**\n * Returns a typed array of every enum properties there is in the enum.\n * @param obj An enum object\n * @returns An array of every enum properties\n */\nexport function enumKeys<O extends object, K extends keyof O = keyof O>(\n  obj: O\n): K[] {\n  return Object.keys(obj).filter(k => !Number.isNaN(k)) as K[]\n}\n\nexport type _Key<T extends { [k: string]: any }> = Extract<keyof T, string>\n","export function arrayRemove<T>(array: T[], item: T): T[]\nexport function arrayRemove<T>(\n  array: T[],\n  findFn: (item: T) => boolean,\n  onlyOnce?: boolean\n): T[]\nexport function arrayRemove<T>(\n  array: T[],\n  par2: T | ((item: T) => boolean),\n  onlyOnce = false\n) {\n  if (typeof par2 === \"function\") {\n    const test = par2 as (item: T) => boolean\n    for (let i = array.length - 1; i >= 0; i--) {\n      if (test(array[i])) {\n        array.splice(i, 1)\n        if (onlyOnce) break\n      }\n    }\n  } else {\n    const idx = array.indexOf(par2)\n    if (idx > -1) {\n      array.splice(idx, 1)\n    }\n  }\n  return array\n}\n\n/**\n * Returns the array position (0-based) of an element in an array, tested using\n * a test function. If the test function returns true for an element in the\n * array, its index will be returned. Array is parsed from left to right.\n *\n * @returns Index of the element or -1 if not in the array\n */\nexport function arrayIndexOf<T>(arr: T[], test: (item: T) => boolean): number {\n  let idx = -1\n  for (let i = 0; i < arr.length; i++) {\n    if (test(arr[i])) {\n      idx = i\n      break\n    }\n  }\n  return idx\n}\n\nexport type TArrayCompareFn<T = any> = (a: T, b: T) => boolean\nexport type TArrayCopyFn<T = any> = (array: T[]) => T[]\n\nexport function arrayRemoveDuplicates<T = any>(\n  array: T[],\n  isSame: TArrayCompareFn<T> = (a, b) => a === b,\n  arrayCopy: TArrayCopyFn<T> = arr => arr\n): T[] {\n  const ret = arrayCopy(array)\n  for1: for (let i = array.length - 1; i >= 1; i--) {\n    for (let j = i - 1; j >= 0; j--) {\n      if (isSame(array[i], array[j])) {\n        ret.splice(i, 1)\n        continue for1\n      }\n    }\n  }\n  return ret\n}\n","export type TSplitsTransformer = (splits: any[], index: number) => number\n\nexport const transformSplitsEqual: TSplitsTransformer = splits => {\n  return Math.floor(1000 / splits.length)\n}\n\nexport const transformSplitsSum1000: TSplitsTransformer = (splits, index) => {\n  return (\n    Math.floor(1000 / splits.length) + (index < 1000 % splits.length ? 1 : 0)\n  )\n}\n\nexport const transformSplitsSum100: TSplitsTransformer = (splits, index) => {\n  return Math.floor(100 / splits.length) + (index < 100 % splits.length ? 1 : 0)\n}\n\nexport const transformSplitsAccessList: TSplitsTransformer = (\n  splits,\n  index\n) => {\n  return splits[index].pct\n}\n","/**\n * @author fxhash <dev@fxhash.xyz>\n * @license MIT\n *\n * A Promise-based generic EventEmitter, in the spirit of JS EventTarget & node\n * js EventEmitter.\n */\n\ntype OptionalIfUndefined<T> = (T extends undefined ? [] : never) | [T]\ntype EventMap = Record<string, any>\ntype EventKey<T extends EventMap> = string & keyof T\ntype EventReceiver<T> = (payload: T) => void | Promise<void>\n\nexport interface IEventEmitter<T extends EventMap> {\n  on<K extends EventKey<T>>(name: K, fn: EventReceiver<T[K]>): () => void\n  off<K extends EventKey<T>>(name: K, fn: EventReceiver<T[K]>): void\n  emit<K extends EventKey<T>>(\n    name: K,\n    ...[payload]: OptionalIfUndefined<T[K]>\n  ): Promise<void>\n}\n\n/**\n * A simple EventEmitter class, in the spirit of NodeJS EventEmitter & browser\n * APIs EventTarget. Supports `await this.emit(...)`.\n */\nexport class EventEmitter<T extends EventMap> implements IEventEmitter<T> {\n  private _listeners: {\n    [K in EventKey<T>]?: EventReceiver<T[K]>[]\n  } = {}\n  private _muted: { [K in EventKey<T>]?: boolean } = {}\n  private _only: EventKey<T>[] | null = null\n\n  /**\n   * Attach a listener on event of given name.\n   * @param name Event name\n   * @param fn Listener\n   * @returns A function which can be used to remove the event listener which\n   * was just set.\n   */\n  public on<K extends EventKey<T>>(\n    name: K,\n    fn: EventReceiver<T[K]>\n  ): () => void {\n    if (!this._listeners.hasOwnProperty(name)) {\n      this._listeners[name] = []\n    }\n    this._listeners[name]!.push(fn)\n    return () => this.off(name, fn)\n  }\n\n  /**\n   * Detach a listener on event of given name. If such listener isn't attached\n   * anymore, nothing happens. If the same listener was somehow registered\n   * multiple times, they will all be removed. An equality check is made on\n   * the listener function.\n   * @param name Event name\n   * @param fn Listener to remove\n   */\n  public off<K extends EventKey<T>>(name: K, fn: EventReceiver<T[K]>): void {\n    const currentListeners = this._listeners[name]\n    if (!currentListeners) return\n    const listeners: EventReceiver<T[K]>[] = []\n    for (let i = 0, length = currentListeners.length; i < length; i++) {\n      if (currentListeners[i] !== fn) {\n        listeners.push(currentListeners[i])\n      }\n    }\n    this._listeners[name] = listeners\n  }\n\n  /**\n   * Immediately call all the listeners on event of given name, and resolves\n   * once all the listeners have resolved.\n   *\n   * @param name Event name to dispatch\n   * @param payload Payload to dispatch\n   */\n  public async emit<K extends EventKey<T>>(\n    name: K,\n    ...[payload]: OptionalIfUndefined<T[K]>\n  ): Promise<void> {\n    if (this._only && !this._only.includes(name)) return\n    if (this._muted[name]) return\n    const listeners = this._listeners[name]\n    if (!listeners) return\n    await Promise.allSettled(\n      listeners.map(listener => Promise.resolve(listener(payload as any)))\n    )\n  }\n\n  /**\n   * Forwards all the events of a given `name` emitted by this emitter to a\n   * target `emitter`. Whenever this emitter will emit `name`, the target\n   * `emitter` will also emit `name` with the same payload.\n   * @param name Event name\n   * @param emitter Target Event Emitter which should emit the same event when\n   * this emitter emits it.\n   * @returns A function to clear the pipe.\n   */\n  public pipe<K extends EventKey<T>>(\n    name: K,\n    emitter: EventEmitter<T>\n  ): () => void {\n    return this.on(name, payload => emitter.emit(name, payload))\n  }\n\n  /**\n   * Mute/Unmute a particular event of the Event Emitter. If muted, no event of\n   * such kind will be emitted when the `emit()` method is called.\n   * @param event Event key to be muted\n   * @param muted Whether the emitter should be muted or not\n   */\n  public mute(event: EventKey<T>, muted: boolean = true): this {\n    this._muted[event] = muted\n    return this\n  }\n\n  /**\n   * Restricts this Event Emitter from only emitting a given list of events. Any\n   * other event will be ignored. This overrides the `mute(true)` option for an\n   * event (an event which was explicitely set to `mute(evt, true)` will not\n   * pass if it's not part of the array provided to this function).\n   *\n   * @param events A list of the only events which can be emitted\n   */\n  public only(...events: EventKey<T>[]): this {\n    this._only = events\n    return this\n  }\n}\n","type Cleaner = () => void\n\n/**\n * Simple cleanup utility.\n *\n * @example\n *\n * ```ts\n * const clean = cleanup()\n * //...\n * clean.add(\n *   () => document.removeEventListener(\"click\", clickHandler),\n *   () => document.removeEventListener(\"mousemove\", mouseHandler),\n * )\n * //...\n * clean.clear()\n * ```\n */\nexport function cleanup(): {\n  add: (...cleaners: Cleaner[]) => number\n  clear: () => void\n} {\n  const _toClean: Cleaner[] = []\n  return {\n    add: (...cleaners: Cleaner[]) => _toClean.push(...cleaners),\n    clear: () => {\n      _toClean.forEach(fn => fn())\n      _toClean.length = 0\n    },\n  }\n}\n","import { invariant } from \"../\"\n\nexport enum Init {\n  NOT_STARTED = \"NOT_STARTED\",\n  STARTED = \"STARTED\",\n  FINISHED = \"FINISHED\",\n  FAILED = \"FAILED\",\n}\n\nconst initStartErrorMessage = {\n  [Init.STARTED]: `Initialization already in process`,\n  [Init.FINISHED]: `Already been intialized`,\n  [Init.FAILED]: `Already failed`,\n}\n\nconst initFinishErrorMessage = {\n  [Init.NOT_STARTED]: `Initialization cannot finish if it has not started`,\n  [Init.FINISHED]: `Initialization has already finished`,\n  [Init.FAILED]: `Already failed`,\n}\n\n/**\n * An utility initialization module for handling async initializations which can\n * only be done once.\n *\n * @example\n *\n * ```ts\n * class Something {\n *   private _init = initialization()\n *\n *   public async init() {\n *     this._init.start() // will throw if already started\n *     // ... some async stuff ...\n *     this._init.finish()\n *   }\n *\n *   public requiresInit() {\n *     this._init.check(\"not finished\") // throws if not finished\n *   }\n * }\n * ```\n */\nexport function intialization<Err extends Error = any>() {\n  let state: Init = Init.NOT_STARTED\n  let failReason: InitializationError<Err> | undefined\n\n  return {\n    /**\n     * The initialization state. **Note:** while exposed by the API it is not\n     * recommended to use this value directly.\n     */\n    get state(): Init {\n      return state\n    },\n    /**\n     * Whether the initialization is finished.\n     */\n    get finished(): boolean {\n      return state === Init.FINISHED\n    },\n    /**\n     * Whether the initialization has failed.\n     */\n    failed(): boolean {\n      return state === Init.FAILED\n    },\n    /**\n     * When initialization fails, this function should be called to set the\n     * state as failed.\n     * @param reason Failure reason\n     */\n    fail(reason: Err): InitializationError<Err> {\n      invariant(reason, \"a fail reason must be provided\")\n      state = Init.FAILED\n      failReason = new InitializationError(reason)\n      return failReason\n    },\n    /**\n     * The reason of failure, or null if no failure happened.\n     */\n    get failReason(): InitializationError<Err> | undefined {\n      return failReason\n    },\n    /**\n     * Throws an error if initialization is not finished.\n     * @param message Optional message for thrown exception\n     */\n    check(message?: string): void {\n      if (state === Init.FAILED) throw failReason\n      invariant(\n        state === Init.FINISHED,\n        message || \"Initialization not finished\"\n      )\n    },\n    /**\n     * Sets the initialization state to `STARTED`. Will throw an error if the\n     * initialization is either `STARTED` (in progress) or `FINISHED`. This\n     * module is only designed for only-once initialization processes.\n     * @param message Optional message for thrown exception\n     */\n    start(message?: string): void {\n      invariant(\n        state === Init.NOT_STARTED,\n        message ||\n          initStartErrorMessage[\n            state as Init.FINISHED | Init.STARTED | Init.FAILED\n          ]\n      )\n      state = Init.STARTED\n    },\n    /**\n     * Sets the initialization state to `FINISHED`. Will throw an error if the\n     * current initialization state is `NOT_STARTED` or `FINISHED`: it's only\n     * possible to finish an intialization which has started but isn't finished.\n     * @param message Optional message for thrown exception\n     */\n    finish(message?: string): void {\n      invariant(\n        state === Init.STARTED,\n        message ||\n          initFinishErrorMessage[\n            state as Init.FINISHED | Init.NOT_STARTED | Init.FAILED\n          ]\n      )\n      state = Init.FINISHED\n    },\n  }\n}\n\nexport type Initialization = ReturnType<typeof intialization>\n\nclass UnknownError extends Error {\n  name = \"UnknownError\" as const\n}\n\nexport class InitializationError<Reason extends Error> extends Error {\n  name = \"InitializationError\" as const\n  cause: Reason | UnknownError\n  constructor(cause?: Reason) {\n    super(\"InitializationError\")\n    this.cause = cause || new UnknownError()\n  }\n}\n\n/**\n * @example\n *\n * ```ts\n * const init = initialization()\n * const initFn = initOnce(init, async () => {\n *   // do async tasks...\n * })\n * await initOnce() // ok\n * await initOnce() // throws\n * ```\n */\nexport function initOnce(\n  init: Initialization,\n  fn: () => Promise<void>\n): () => Promise<void> {\n  return async () => {\n    try {\n      init.start()\n      await fn()\n      init.finish()\n    } catch (err: any) {\n      throw init.fail(err)\n    }\n  }\n}\n","/**\n * Check if `x` is not null or undefined. If not, narrows `x` type with a\n * `NonNullable<x>` predicate.\n * @param x The variable to test\n * @returns A boolean which indicates whether `x` is nullable or not\n */\nexport function nonNullable<T>(x: T): x is NonNullable<T> {\n  return typeof x !== \"undefined\" && x !== null\n}\n","import { sleep } from \"./_index\"\n\nexport interface IRetryOptions<FnReturnType> {\n  /**\n   * How many times at maximum should the function be retried until an error\n   * is returned.\n   * @default 3\n   */\n  maxRetries?: number\n\n  /**\n   * The delay (in milliseconds) between retries. The interval starts as soon as\n   * the function to retry is called.\n   * @default 1000\n   */\n  interval?: number\n\n  /**\n   * If set, a delay (in milliseconds) before the attempt is considered as\n   * failed an a new one is attempted (except if `maxRetries`) has been reached.\n   * @default undefined\n   */\n  timeout?: number\n\n  /**\n   * If defined, will be called when a retry is attempted. It can be used to\n   * abort a fetch attempt for instance.\n   * @default undefined\n   */\n  onRetry?: (attempts: number) => void\n\n  /**\n   * If defined, this function will be called when the called function\n   * **successfully resolves**, and dictates whether a retry should be attempted\n   * or not. This can be useful when a promise always returns some kinf of\n   * `Result<Success, Failure>` (ie it never throws), but still has failed.\n   * @default `() => false` (never retries if promise resolves)\n   *\n   * @param result A successful resolution of the called function.\n   * @returns true => retry, false => no retry\n   */\n  shouldRetryOnSuccess?: (result: FnReturnType) => boolean\n}\n\n/**\n * Decorates an async function with `retry()`: the function will be callable in\n * the same fashion as it was, but will have a retry mechanism implemented. This\n * function internally calls `retry()` from this same package.\n *\n * @param fn An async function\n * @param options Retry options\n *\n * @returns A function which will automatically retry until fn() resolves, or\n * `maxRetries` have been reached.\n * @throws When `maxRetries` have been reached\n */\nexport function retriable<FnParams extends any[], FnReturn>(\n  fn: (...params: FnParams) => Promise<FnReturn>,\n  options: IRetryOptions<FnReturn> = {}\n): (...params: FnParams) => Promise<FnReturn> {\n  return async (...params: FnParams) => {\n    return retry(() => fn(...params), options)\n  }\n}\n\n/**\n * Retries to run an async function until it resolves (in which case this\n * function resolves with sudhc value) or until maxRetries have been attempted,\n * in which case this function throws with either the last error throws by the\n * function or `MaxRetriesError` if the function has always timeout.\n *\n * @param fn A function which returns a promise, which will be retried until it\n * resolves (or until maxRetries have been reached)\n * @param options Retry options\n *\n * @returns The promise resolve value.\n * @throws When maxRetries have been reached with either the last error thrown\n * by the fn, or MaxRetriesError if every call has timeout.\n */\nexport async function retry<FnReturn>(\n  fn: () => Promise<FnReturn>,\n  options: IRetryOptions<FnReturn> = {}\n): Promise<FnReturn> {\n  const {\n    maxRetries = 3,\n    interval = 1000,\n    timeout,\n    onRetry,\n    shouldRetryOnSuccess,\n  } = options\n  let retries = 0,\n    start: number,\n    fnError: any = null\n\n  while (retries <= maxRetries) {\n    retries > 0 && onRetry?.(retries)\n    start = performance.now()\n    const promises = [fn()]\n    if (typeof timeout !== \"undefined\") {\n      promises.push(\n        (async () => {\n          await sleep(timeout)\n          throw new TimeoutError()\n        })()\n      )\n    }\n    try {\n      const res = await Promise.race(promises)\n      // return except if instructed otherwise with `shouldRetryOnSuccess`\n      if (shouldRetryOnSuccess?.(res)) {\n      } else return res\n    } catch (err) {\n      if (!(err instanceof TimeoutError)) fnError = err\n    }\n\n    // need a retry if it hasn't returned\n    const duration = performance.now() - start\n    const effectiveInterval = interval - duration\n    if (effectiveInterval > 0) await sleep(effectiveInterval)\n    retries++\n  }\n\n  throw fnError || new MaxRetriesError()\n}\n\nclass TimeoutError extends Error {\n  name = \"TimeoutError\" as const\n}\n\nclass MaxRetriesError extends Error {\n  name = \"MaxRetriesError\" as const\n}\n","/**\n * @author fxhash <dev@fxhash.xyz>\n * @license MIT\n *\n * Control commands.\n */\n\n/**\n * Returns a promise which resolves after given time.\n * @param ms The number of milliseconds\n */\nexport function sleep(ms: number): Promise<void> {\n  return new Promise<void>(resolve => setTimeout(resolve, ms))\n}\n","import { sleep } from \"./_index\"\n\nexport type SetIntervalCappedOptions = {\n  /**\n   * The time, in milliseconds, the timer should delay in between executions of\n   * the specified function or code.\n   * @default 0\n   */\n  delay: number\n\n  /**\n   * Maximum number of steps before the setInterval resolves.\n   * @default 20\n   */\n  maxSteps: number\n}\n\ntype IntervalFnReturnType = true | void\ntype IntervalFn = () => Promise<IntervalFnReturnType> | IntervalFnReturnType\n\n/**\n * fn() will be called on every interval, until a max number of steps is reached\n * or fn() returns true.\n * @param fn A function which returns true or void. If true is returned, the\n * interval will be stopped.\n * @param param1 Options\n */\nexport async function setIntervalCapped(\n  fn: IntervalFn,\n  { delay = 0, maxSteps = 20 }: SetIntervalCappedOptions\n): Promise<void> {\n  for (let i = 0; i < maxSteps; i++) {\n    if ((await Promise.resolve(fn())) === true) return\n    await sleep(delay)\n  }\n}\n","/**\n * A singleton wrapper for functionnal programming. The function passed will\n * only be called once the first time the singleton is called, then the same\n * reference will be returned.\n *\n * @param generator A function which instanciates some object\n * @param warning Whether a console.warning with the given value should be\n * emitted when there's already an instance.\n *\n * @returns A function which will return an existing instance or call the\n * generator to instanciate object.\n *\n * @example\n *\n * ```ts\n * const Singleton = singleton((a: string) => {\n *   let rnd = Math.random()\n *   console.log(a)\n *   return {\n *     rnd,\n *   }\n * })\n *\n * const callA = Singleton(\"hello\") // log \"hello\"\n * const callB = Singleton(\"world\") // log \"world\"\n * callA.rnd === callB.rnd // true\n * ```\n */\nexport function singleton<T, U extends unknown[]>(\n  generator: (...args: U) => T,\n  warning?: string\n): (...args: U) => T {\n  const instance: T | null = null\n  return (...args: U) => {\n    if (instance) {\n      if (warning) console.warn(warning)\n      return instance\n    }\n    return generator(...args)\n  }\n}\n","import { sleep } from \".\"\n\ntype StopConditionType = (tryIdx: number) => boolean\n\n/**\n * Fetch with some retries\n * @param url the URL to fetch\n * @param maxRetries maximum number of retries before giving up, and throwing an error\n * @param delay time between each call (waits for the end of previous call)\n * @param stopCondition a function which will be called before each iteration, if it returns false, it stops\n * @returns\n */\nexport const fetchRetry = async (\n  url: string,\n  maxRetries: number = 5,\n  delay: number = 200,\n  shouldStop: StopConditionType = () => false,\n  timeout: number | false = false\n): Promise<Response> => {\n  let error: any\n  for (let i = 0; i < maxRetries; i++) {\n    if (shouldStop(i)) break\n    try {\n      const controller = new AbortController()\n      if (timeout !== false) {\n        setTimeout(() => controller.abort(), timeout)\n      }\n      const data = await fetch(url, {\n        signal: controller.signal,\n      })\n      if (data.status === 404) throw \"404\"\n      return data\n    } catch (err) {\n      error = err\n    }\n    await sleep(delay)\n  }\n  throw error\n}\n\nexport interface FetchOptions extends RequestInit {\n  retries?: number\n  initialDelayMs?: number\n  shouldWaitBeforeRetry?: (error: any) => boolean\n  factor?: number\n  randomizationFactor?: number\n  maxDelayMs?: number\n}\n\nexport const isRateLimitError = (error: any): boolean => {\n  const TOO_MANY_REQUESTS = 429\n  return error.status === TOO_MANY_REQUESTS\n}\n\nconst OK_STATUSES = new Set([200, 201, 202, 203, 204, 205, 206])\n\n/**\n * This function tries to fetch a url, and if it fails, waits an exponentially\n * increasing amount of time before trying again, until a maximum number of\n * retries have been reached.\n */\nexport const fetchExponentialBackoff = async (\n  url: string,\n  options: FetchOptions = {}\n): Promise<Response> => {\n  const {\n    retries = 5,\n    initialDelayMs = 2000,\n    shouldWaitBeforeRetry = isRateLimitError,\n    factor = 2,\n    randomizationFactor = 0.5,\n    maxDelayMs = 60000,\n    ...fetchOptions\n  } = options\n\n  let currentDelay = initialDelayMs\n\n  for (let attempt = 0; attempt <= retries; attempt++) {\n    try {\n      const response = await fetch(url, fetchOptions)\n      if (!OK_STATUSES.has(response.status)) {\n        throw response\n      }\n      return response\n    } catch (error: any) {\n      if (attempt === retries) {\n        throw error\n      }\n\n      if (shouldWaitBeforeRetry(error)) {\n        const jitter = 1 + randomizationFactor * (Math.random() * 2 - 1)\n        const delay = Math.min(currentDelay * jitter, maxDelayMs)\n        await sleep(delay)\n        currentDelay = Math.min(currentDelay * factor, maxDelayMs)\n      }\n    }\n  }\n\n  throw new Error(\"Maximum retries reached\")\n}\n","/**\n * Converts a floating-point number to its hexadecimal representation.\n *\n * This function takes a number (float or double) and returns its IEEE 754\n * double-precision floating-point representation as a hexadecimal string.\n *\n * @param n - The floating-point number to convert.\n * @returns A string representing the hexadecimal value of the input number.\n *          The string is 16 characters long, representing 8 bytes (64 bits)\n *          of the double-precision floating-point number.\n *\n * @example\n * console.log(float2hex(3.14159));\n * // Output: \"400921fb54442d18\"\n *\n * @remarks\n * - The function uses a DataView to handle the binary representation\n *   of the number.\n * - The resulting string is in big-endian order.\n * - This function works for both positive and negative numbers, including special\n *   values like Infinity, -Infinity, and NaN.\n */\n\nexport function float2hex(n: number): string {\n  const getHex = (i: number) => i.toString(16).padStart(2, \"0\")\n  const view = new DataView(new ArrayBuffer(8))\n  view.setFloat64(0, n)\n\n  return [...Array(8)].map((_, i) => getHex(view.getUint8(i))).join(\"\")\n}\n","const DEFAULT_RETRY_OPTIONS = {\n  maxAttempts: 5,\n  initialDelay: 500,\n  maxDelay: 32000,\n  factor: 2,\n  jitter: 0.1,\n}\n\ninterface RetryOptions {\n  maxAttempts?: number\n  initialDelay?: number\n  maxDelay?: number\n  factor?: number\n  jitter?: number\n}\n\nexport async function withExponentialBackoff<T>(\n  operation: () => Promise<T>,\n  options: RetryOptions = {}\n): Promise<T> {\n  const opts = { ...DEFAULT_RETRY_OPTIONS, ...options }\n  let attempt = 1\n  let delay = opts.initialDelay\n\n  while (true) {\n    try {\n      return await operation()\n    } catch (error) {\n      if (attempt >= opts.maxAttempts) {\n        throw error\n      }\n\n      // Calculate delay with jitter\n      const jitterAmount = delay * opts.jitter\n      const actualDelay = delay + (Math.random() * 2 - 1) * jitterAmount\n\n      await new Promise(resolve => setTimeout(resolve, actualDelay))\n\n      delay = Math.min(delay * opts.factor, opts.maxDelay)\n      attempt++\n    }\n  }\n}\n"],"mappings":"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"}