import { getBlockchainFromAddress$1 as getBlockchainFromAddress, isBaseAddressValid$1 as isBaseAddressValid, isBlockchainAddressValid$1 as isBlockchainAddressValid, isEthereumAddressValid$1 as isEthereumAddressValid, isTezosAddressValid$1 as isTezosAddressValid, mockBaseAddress$1 as mockBaseAddress, mockBlockchainAddress$1 as mockBlockchainAddress, mockEthereumAddress$1 as mockEthereumAddress, mockTezosAddress$1 as mockTezosAddress } from "./address-tenDjARi.js";
import { getBlockchainFromTransactionHash$1 as getBlockchainFromTransactionHash, isBaseTransactionHashValid$1 as isBaseTransactionHashValid, isEthereumTransactionHashValid$1 as isEthereumTransactionHashValid, isTezosTransactionHashValid$1 as isTezosTransactionHashValid, isTransactionHashValid$1 as isTransactionHashValid, mockBaseTransactionHash$1 as mockBaseTransactionHash, mockEthereumTransactionHash$1 as mockEthereumTransactionHash, mockTezosTransactionHash$1 as mockTezosTransactionHash, mockTransactionHash$1 as mockTransactionHash } from "./hash-1shvhLPc.js";
import { RandFunction, ResettableRandFunction, createFxRandom$1 as createFxRandom, getRandomHash$1 as getRandomHash } from "./math-BAhNgf-4.js";
import { HashParams, parseHashParams$1 as parseHashParams } from "./url-cswwfUuL.js";

//#region src/base58.d.ts
/**
 * Encodes a 32 bytes hex string with base58check, and pads the output with
 * an initial information byte "o", just like Tezos operations.
 * @param hex input 32 bytes hex string to encode
 */
declare function b58checkHexString(hex: string): string;
//#endregion
//#region src/bytes.d.ts
/**
 * Very quick string hashing algorithm where each character is passed through
 * some xorshift variant to produce some 64bit hash represented as a number.
 * Can be useful when there is a need to derive some unique ID for unique
 * strings in a fast way.
 *
 * @param str A string as input
 *
 * @returns A hash as a 64bit number for faster processing
 *
 * @example
 * ```ts
 * const hash = xorshiftString("hello world") // 7d2fb77d
 * const hash = xorshiftString("hey")          // 216e3ffa
 * const hash = xorshiftString("a")            // 704e3821
 * const hash = xorshiftString("b")            // 4e37a71e
 * ```
 */
declare function xorshiftString(str: string): number;
/**
 * Computes a 64bit hash (returned as a number) for any serializable value
 * passed. The value must be serializable using `JSON.stringify()` otherwise
 * this function throws.
 *
 * Under the hood, does `xorshiftString(JSON.stringify(serializable))`
 *
 * @param serializable A value which can be serialized with `JSON.stringify()`
 *
 * @returns A 64bit hash as a number
 *
 * @example
 * ```ts
 * const hash = xorshift64({ some: "value", numb: 2 }) // 7e34a2b7
 * ```
 */
declare function xorshift64(serializable: any): number;
//#endregion
//#region src/uint8.d.ts
/**
 * Outputs the lowercase hex string representation of a Uint8Array
 * @param uint8 A sequence of bytes to convert
 * @returns The lowercase hex string representation of the Uint8Array
 *
 * @example
 *
 * const arr = new Uint8Array(255, 0, 128, 0, 128, 255)
 * const hex = uint8(arr) // "ff00800080ff"
 */
declare function u8hex(uint8: Uint8Array): string;
//#endregion
//#region src/string.d.ts
/**
 * Turn the first character of a string into an UPPERCASE letter.
 * @param str String to capitalize
 * @returns Capitalized string
 *
 * @example
 *
 * capitalize("abcde") // "Abcde"
 */
declare function capitalize(str: string): string;
declare function truncateMiddle(str: string, length: number, ellipsis?: string): string;
/**
 * Generates a *unique* string ID, using `Date.now()` and `Math.random()`. IDs
 * may not have the same length.
 *
 * **Warning: not cryptographically secure!**
 *
 * @returns A *unique* string ID
 */
declare function uniqueId(): string;
/**
 * Splits a string in 2 sections at a given index, and returns these 2 sections.
 */
declare function splitStringAt(str: string, index: number): [string, string];
/**
 * convert a string of tags separated by commas into an array of tags
 * @param str String of tags separated by commas
 * @returns Array\<string> of tags
 */
declare function tagsFromString(str: string): string[];
/**
 * convert an array of bytes into a string
 * @param byteArray Array of numbers to
 * @returns String
 */
declare function bytesToString(byteArray: number[]): string;
/**
 * convert string to byte string
 * @param str String to convert
 * @returns Byte string
 */
declare function stringToByteString(str: string): string;
//#endregion
//#region src/types/errors.d.ts
/**
 * An error that occurs when a task violates a logical condition that is assumed to be true at all times.
 */
declare class InvariantError extends Error {
  name: "InvariantError";
}
/**
 * Asserts that the given condition is truthy
 *
 * @param condition - Either truthy or falsy value
 * @param message - An error message
 */
declare function invariant(condition: unknown, message: string): asserts condition;
//#endregion
//#region src/types/result.d.ts
type Primitive$1 = string | number | boolean | bigint | symbol | undefined | null;
type Cast<A, B> = A extends B ? A : B;
type Narrow<A> = Cast<A, [] | (A extends Primitive$1 ? A : never) | { [K in keyof A]: Narrow<A[K]> }>;
/**
 * A `Success<T, E>` represents a successful computation that returns a value of type `T`.
 *
 * `E` in `Success<T, E>` is the type of the error that would have been returned in case of failure.
 * It's present only to allow type safety of the `isFailure` method.
 *
 * @sealed
 * @privateRemarks DO NOT EXPORT, see type export later on
 * @typeParam T - the success value type
 */
declare class Success<T> {
  readonly value: T;
  /** @internal */
  constructor(value: T);
  isSuccess(): this is Success<T>;
  isFailure(): this is Failure<unknown>;
  unwrap(): T;
}
/**
 * A `Success<T, E>` represents a successful computation that returns a value of type `T`.
 *
 * `T` in `Failure<T, E>` is the type of the value that would have been returned in case of success.
 * It's present only to allow type safety of the `isSuccess` method.
 *
 * @sealed
 * @privateRemarks DO NOT EXPORT, see type export later on
 * @typeParam E - the failure error type
 */
declare class Failure<E> {
  readonly error: E;
  /** @internal */
  constructor(error: E);
  isSuccess(): this is Success<unknown>;
  isFailure(): this is Failure<E>;
  unwrap(): never;
}
/**
 * An `IEquatableError` is an error that can be compared by name.
 *
 */
interface IEquatableError<T extends string = string, P = Narrow<T>> {
  name: P;
}
/**
 * A `Result` type represents either `Success` or `Failure`.
 *
 * **TL;DR**
 *
 * `Result` is a minimalist implementation of a value that can be a "success" or a "failure".
 * It borrows from what done in other modern languages (i.e. Rust, Kotlin, Swift, etc.).
 *
 * The Lens SDK adopts this pattern in order to:
 * - be explicit about the known failure scenarios of a task,
 * - provide a way for consumers to perform exhaustive error handling,
 * - makes control flow easier to reason about.
 *
 * @remarks
 *
 * You might be familiar with the `Either` type from functional programming. The `Result` type
 * could be seen as a more specific version of `Either` where the left side is reserved for
 * success scenarios and the right side is reserved for known failure scenarios.
 *
 * Think of failure scenarios as alternative outcomes of a given task that although not the "happy path",
 * are still legitimate results for the task within the boundary of a correct usage of the SDK.
 *
 * In promoting exhaustive error handling, the Lens SDK makes it easier to evolve your code
 * when a new error case is added or a case is removed.
 * For example after a Lens SDK upgrade you can simply run the TS compiler to figure out where you
 * need to handle the new error cases, or even better, it guides you to remove obsolescent code
 * where an error case is no longer possible. This is virtually impossible with a `try/catch` approach.
 *
 * Thrown exceptions are historically difficult to trace. They require implicit knowledge
 * of the implementation details of the code that might throw exceptions. This might go several
 * layers down and leads to tight coupling between modules.
 *
 * The Lens SDK still throws exceptions where the error is not a "normal execution scenario".
 * These are considered real "exceptional circumstances" and not alternative outcomes and it's up to the consumer to `try/catch` them.
 *
 * An example of errors that are thrown by the SDK is {@link InvariantError}. They are often thrown as result of a misuse of the SDK.
 * By throwing them we want to fail fast so the consumer can fix the issue as soon as possible.
 * Specifically for `InvariantError`, there is no need to code defensively against these errors. Just rectify the coding issue and move on.
 *
 * @example
 * Control flow
 * ```ts
 * const result: Result<number, RangeError> = doSomething();
 *
 * if (result.isFailure()) {
 *   // because of the `isFailure` check above, TS knows that `result` is a `Failure<RangeError>` here
 *   console.log(result.error); // result.error gets narrowed to `RangeError`
 *
 *   return; // early return
 * }
 *
 * // because of the `isFailure` check above and the early return, TS knows that `result` is a `Success<number>` here
 * console.log(result.value); // result.value gets narrowed to `number`
 * ```
 *
 * @example
 * Exhaustive error handling
 *
 * Given a result type like the following:
 *
 * ```ts
 * const result: Result<number, PendingSigningError | WalletConnectionError> = doSomething();
 * ```
 * You can use a function with a `switch` statement to perform exhaustive error handling:
 * ```ts
 * function format(failure: Failure<PendingSigningError | WalletConnectionError>): string {
 *   switch (failure.error.name) {
 *     case 'PendingSigningError':
 *       return 'Please sign the transaction';
 *       break;
 *     case 'WalletConnectionError':
 *       return 'Please connect your wallet and try again';
 *       break;
 *   }
 *   // any code after the switch statement is unreachable
 * }
 * ```
 * The example above assumes `allowUnreachableCode: false` in your `tsconfig.json`.
 *
 * An even more robust way to perform exhaustive error handling with a `switch` is to use the `never` type: see {@link https://www.typescriptlang.org/docs/handbook/2/narrowing.html#exhaustiveness-checking | exhaustiveness checking}.
 *
 * @see https://wiki.c2.com/?AvoidExceptionsWheneverPossible
 * @see https://developer.apple.com/documentation/swift/result
 * @see https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-result/
 * @see https://the-guild.dev/blog/graphql-error-handling-with-fp#monads-to-the-rescue
 *
 * @typeParam T - the success value type
 * @typeParam E - the failure error type
 */
type Result<T, E extends IEquatableError> = Success<T> | Failure<E>;
/**
 * A `PromiseResult` is a convenience type alias that represents either a {@link Result} in the context of asynchronous tasks.
 *
 * @typeParam T - the success value type
 * @typeParam E - the failure error type
 */
type PromiseResult<T, E extends IEquatableError> = Promise<Result<T, E>>;
/**
 * @internal
 */
declare function success(): Success<void>;
declare function success<T>(value: T): Success<T>;
/**
 * @internal
 */
declare const failure: <E extends IEquatableError>(error: E) => Failure<E>;
/**
 * Ensures the `Result<T, E>` is a `Success<T>`.
 */
declare function assertSuccess<T>(result: Result<T, IEquatableError>): asserts result is Success<T>;
/**
 * Ensures the `Result<T, E>` is a `Failure<E>`.
 */
declare function assertFailure<T, E extends IEquatableError>(result: Result<T, E>): asserts result is Failure<E>;
//#endregion
//#region src/types/objects.d.ts
/**
 * Make the fields of an object NonNullable
 */
type NonNullableFields<T> = { [P in keyof T]: NonNullable<T[P]> };
/**
 *
 * @example
 *
 * ```ts
 * interface MyInterface {
 *   prop1?: string;
 *   prop2?: number;
 * }
 *
 * // Use the utility type to create a new type that enforces the constraint
 * type TOne = AtLeastOne<MyInterface>;
 *
 * const example1: TOne = { prop1: "Hello" }; // Valid
 * const example2: TOne = { prop2: 42 }; // Valid
 * const example3: TOne = { prop1: "Hello", prop2: 42 }; // Valid
 * const example4: TOne = {}; // Error: At least one property required
 */
type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> & U[keyof U];
type Only<T, U> = { [P in keyof T]: T[P] } & { [P in keyof U]?: never };
/**
 * When you need either interface, but don't want to accept both.
 *
 * @example
 *
 * ```ts
 * interface One {
 *   a: string
 * }
 * interface Two {
 *   b: string
 * }
 * type OneOrTwo = Either<One, Two>
 *
 * function f(par: OneOrTwo) {}
 *
 * f({ a: "" }) // ok
 * f({ b: "" }) // ok
 * f({ a: "", b: "" }) // not ok
 * ```
 */
type Either<T, U> = Only<T, U> | Only<U, T>;
/**
 * Creates a deep partial type from a given type T.
 *
 * This type recursively makes all properties of T optional, including nested objects.
 * For non-object types, it returns the original type.
 *
 * @example
 *
 * ```ts
 * type Person = {
 *   name: string;
 *   age: number;
 *   address: {
 *     street: string;
 *     city: string;
 *   };
 * };
 *
 * type PartialPerson = DeepPartial<Person>;
 *
 * const valid_update: DeepPartial<Person> = { address: { city: "New York" }, name: "John" } // ok
 * const invalid_update: DeepPartial<Person> = { address: { city: "New York" }, name: "John", age: 30, unknown: true } // Error: Object literal may only specify known properties, and 'unknown' does not exist in type 'DeepPartial<Person>'.
 *```
 */
type DeepPartial<T> = T extends object ? { [P in keyof T]?: DeepPartial<T[P]> } : T;
//#endregion
//#region src/types/deep-omit.d.ts
/**
 * @author Titian Cernicova-Dragomir
 * @source <https://stackoverflow.com/a/55539616>
 */
type Primitive = string | Function | number | boolean | Symbol | undefined | null;
type DeepOmitHelper<T, K extends keyof T> = { [P in K]: T[P] extends infer TP ? TP extends Primitive ? TP : TP extends any[] ? DeepOmitArray<TP, K> : DeepOmit<TP, K> : never };
type DeepOmitArray<T extends any[], K> = { [P in keyof T]: DeepOmit<T[P], K> };
/**
 * Omit a nested key in a type, while keeping the type structure.
 *
 * @author Titian Cernicova-Dragomir
 * @source <https://stackoverflow.com/a/55539616>
 *
 * @example
 *
 * ```ts
 * type A = {
 *   prop: string
 *   nested: {
 *     toRemove: string
 *     ok: string
 *   }
 * }
 *
 * type A2 = DeepOmit<A, "toRemove">
 * // {
 * //   prop: string
 * //   nested: {
 * //     ok: string
 * //   }
 * // }
 * ```
 */
type DeepOmit<T, K> = T extends Primitive ? T : DeepOmitHelper<T, Exclude<keyof T, K>>;
//#endregion
//#region src/types/enums.d.ts
/**
 * Returns a typed array of every enum properties there is in the enum.
 * @param obj An enum object
 * @returns An array of every enum properties
 */
declare function enumKeys<O extends object, K extends keyof O = keyof O>(obj: O): K[];
type _Key<T extends {
  [k: string]: any;
}> = Extract<keyof T, string>;
//#endregion
//#region src/array.d.ts
declare function arrayRemove<T>(array: T[], item: T): T[];
declare function arrayRemove<T>(array: T[], findFn: (item: T) => boolean, onlyOnce?: boolean): T[];
/**
 * Returns the array position (0-based) of an element in an array, tested using
 * a test function. If the test function returns true for an element in the
 * array, its index will be returned. Array is parsed from left to right.
 *
 * @returns Index of the element or -1 if not in the array
 */
declare function arrayIndexOf<T>(arr: T[], test: (item: T) => boolean): number;
type TArrayCompareFn<T = any> = (a: T, b: T) => boolean;
type TArrayCopyFn<T = any> = (array: T[]) => T[];
declare function arrayRemoveDuplicates<T = any>(array: T[], isSame?: TArrayCompareFn<T>, arrayCopy?: TArrayCopyFn<T>): T[];
//#endregion
//#region src/splits.d.ts
type TSplitsTransformer = (splits: any[], index: number) => number;
declare const transformSplitsEqual: TSplitsTransformer;
declare const transformSplitsSum1000: TSplitsTransformer;
declare const transformSplitsSum100: TSplitsTransformer;
declare const transformSplitsAccessList: TSplitsTransformer;
//#endregion
//#region src/events.d.ts
/**
 * @author fxhash <dev@fxhash.xyz>
 * @license MIT
 *
 * A Promise-based generic EventEmitter, in the spirit of JS EventTarget & node
 * js EventEmitter.
 */
type OptionalIfUndefined<T> = (T extends undefined ? [] : never) | [T];
type EventMap = Record<string, any>;
type EventKey<T extends EventMap> = string & keyof T;
type EventReceiver<T> = (payload: T) => void | Promise<void>;
interface IEventEmitter<T extends EventMap> {
  on<K extends EventKey<T>>(name: K, fn: EventReceiver<T[K]>): () => void;
  off<K extends EventKey<T>>(name: K, fn: EventReceiver<T[K]>): void;
  emit<K extends EventKey<T>>(name: K, ...[payload]: OptionalIfUndefined<T[K]>): Promise<void>;
}
/**
 * A simple EventEmitter class, in the spirit of NodeJS EventEmitter & browser
 * APIs EventTarget. Supports `await this.emit(...)`.
 */
declare class EventEmitter<T extends EventMap> implements IEventEmitter<T> {
  private _listeners;
  private _muted;
  private _only;
  /**
   * Attach a listener on event of given name.
   * @param name Event name
   * @param fn Listener
   * @returns A function which can be used to remove the event listener which
   * was just set.
   */
  on<K extends EventKey<T>>(name: K, fn: EventReceiver<T[K]>): () => void;
  /**
   * Detach a listener on event of given name. If such listener isn't attached
   * anymore, nothing happens. If the same listener was somehow registered
   * multiple times, they will all be removed. An equality check is made on
   * the listener function.
   * @param name Event name
   * @param fn Listener to remove
   */
  off<K extends EventKey<T>>(name: K, fn: EventReceiver<T[K]>): void;
  /**
   * Immediately call all the listeners on event of given name, and resolves
   * once all the listeners have resolved.
   *
   * @param name Event name to dispatch
   * @param payload Payload to dispatch
   */
  emit<K extends EventKey<T>>(name: K, ...[payload]: OptionalIfUndefined<T[K]>): Promise<void>;
  /**
   * Forwards all the events of a given `name` emitted by this emitter to a
   * target `emitter`. Whenever this emitter will emit `name`, the target
   * `emitter` will also emit `name` with the same payload.
   * @param name Event name
   * @param emitter Target Event Emitter which should emit the same event when
   * this emitter emits it.
   * @returns A function to clear the pipe.
   */
  pipe<K extends EventKey<T>>(name: K, emitter: EventEmitter<T>): () => void;
  /**
   * Mute/Unmute a particular event of the Event Emitter. If muted, no event of
   * such kind will be emitted when the `emit()` method is called.
   * @param event Event key to be muted
   * @param muted Whether the emitter should be muted or not
   */
  mute(event: EventKey<T>, muted?: boolean): this;
  /**
   * Restricts this Event Emitter from only emitting a given list of events. Any
   * other event will be ignored. This overrides the `mute(true)` option for an
   * event (an event which was explicitely set to `mute(evt, true)` will not
   * pass if it's not part of the array provided to this function).
   *
   * @param events A list of the only events which can be emitted
   */
  only(...events: EventKey<T>[]): this;
}
//#endregion
//#region src/control-flows/cleanup.d.ts
type Cleaner = () => void;
/**
 * Simple cleanup utility.
 *
 * @example
 *
 * ```ts
 * const clean = cleanup()
 * //...
 * clean.add(
 *   () => document.removeEventListener("click", clickHandler),
 *   () => document.removeEventListener("mousemove", mouseHandler),
 * )
 * //...
 * clean.clear()
 * ```
 */
declare function cleanup(): {
  add: (...cleaners: Cleaner[]) => number;
  clear: () => void;
};
//#endregion
//#region src/control-flows/initialization.d.ts
declare enum Init {
  NOT_STARTED = "NOT_STARTED",
  STARTED = "STARTED",
  FINISHED = "FINISHED",
  FAILED = "FAILED",
}
/**
 * An utility initialization module for handling async initializations which can
 * only be done once.
 *
 * @example
 *
 * ```ts
 * class Something {
 *   private _init = initialization()
 *
 *   public async init() {
 *     this._init.start() // will throw if already started
 *     // ... some async stuff ...
 *     this._init.finish()
 *   }
 *
 *   public requiresInit() {
 *     this._init.check("not finished") // throws if not finished
 *   }
 * }
 * ```
 */
declare function intialization<Err extends Error = any>(): {
  /**
   * The initialization state. **Note:** while exposed by the API it is not
   * recommended to use this value directly.
   */
  readonly state: Init;
  /**
   * Whether the initialization is finished.
   */
  readonly finished: boolean;
  /**
   * Whether the initialization has failed.
   */
  failed(): boolean;
  /**
   * When initialization fails, this function should be called to set the
   * state as failed.
   * @param reason Failure reason
   */
  fail(reason: Err): InitializationError<Err>;
  /**
   * The reason of failure, or null if no failure happened.
   */
  readonly failReason: InitializationError<Err> | undefined;
  /**
   * Throws an error if initialization is not finished.
   * @param message Optional message for thrown exception
   */
  check(message?: string): void;
  /**
   * Sets the initialization state to `STARTED`. Will throw an error if the
   * initialization is either `STARTED` (in progress) or `FINISHED`. This
   * module is only designed for only-once initialization processes.
   * @param message Optional message for thrown exception
   */
  start(message?: string): void;
  /**
   * Sets the initialization state to `FINISHED`. Will throw an error if the
   * current initialization state is `NOT_STARTED` or `FINISHED`: it's only
   * possible to finish an intialization which has started but isn't finished.
   * @param message Optional message for thrown exception
   */
  finish(message?: string): void;
};
type Initialization = ReturnType<typeof intialization>;
declare class UnknownError extends Error {
  name: "UnknownError";
}
declare class InitializationError<Reason extends Error> extends Error {
  name: "InitializationError";
  cause: Reason | UnknownError;
  constructor(cause?: Reason);
}
/**
 * @example
 *
 * ```ts
 * const init = initialization()
 * const initFn = initOnce(init, async () => {
 *   // do async tasks...
 * })
 * await initOnce() // ok
 * await initOnce() // throws
 * ```
 */
declare function initOnce(init: Initialization, fn: () => Promise<void>): () => Promise<void>;
//#endregion
//#region src/control-flows/nullish.d.ts
/**
 * Check if `x` is not null or undefined. If not, narrows `x` type with a
 * `NonNullable<x>` predicate.
 * @param x The variable to test
 * @returns A boolean which indicates whether `x` is nullable or not
 */
declare function nonNullable<T>(x: T): x is NonNullable<T>;
//#endregion
//#region src/control-flows/retry.d.ts
interface IRetryOptions<FnReturnType> {
  /**
   * How many times at maximum should the function be retried until an error
   * is returned.
   * @default 3
   */
  maxRetries?: number;
  /**
   * The delay (in milliseconds) between retries. The interval starts as soon as
   * the function to retry is called.
   * @default 1000
   */
  interval?: number;
  /**
   * If set, a delay (in milliseconds) before the attempt is considered as
   * failed an a new one is attempted (except if `maxRetries`) has been reached.
   * @default undefined
   */
  timeout?: number;
  /**
   * If defined, will be called when a retry is attempted. It can be used to
   * abort a fetch attempt for instance.
   * @default undefined
   */
  onRetry?: (attempts: number) => void;
  /**
   * If defined, this function will be called when the called function
   * **successfully resolves**, and dictates whether a retry should be attempted
   * or not. This can be useful when a promise always returns some kinf of
   * `Result<Success, Failure>` (ie it never throws), but still has failed.
   * @default `() => false` (never retries if promise resolves)
   *
   * @param result A successful resolution of the called function.
   * @returns true => retry, false => no retry
   */
  shouldRetryOnSuccess?: (result: FnReturnType) => boolean;
}
/**
 * Decorates an async function with `retry()`: the function will be callable in
 * the same fashion as it was, but will have a retry mechanism implemented. This
 * function internally calls `retry()` from this same package.
 *
 * @param fn An async function
 * @param options Retry options
 *
 * @returns A function which will automatically retry until fn() resolves, or
 * `maxRetries` have been reached.
 * @throws When `maxRetries` have been reached
 */
declare function retriable<FnParams extends any[], FnReturn>(fn: (...params: FnParams) => Promise<FnReturn>, options?: IRetryOptions<FnReturn>): (...params: FnParams) => Promise<FnReturn>;
/**
 * Retries to run an async function until it resolves (in which case this
 * function resolves with sudhc value) or until maxRetries have been attempted,
 * in which case this function throws with either the last error throws by the
 * function or `MaxRetriesError` if the function has always timeout.
 *
 * @param fn A function which returns a promise, which will be retried until it
 * resolves (or until maxRetries have been reached)
 * @param options Retry options
 *
 * @returns The promise resolve value.
 * @throws When maxRetries have been reached with either the last error thrown
 * by the fn, or MaxRetriesError if every call has timeout.
 */
declare function retry<FnReturn>(fn: () => Promise<FnReturn>, options?: IRetryOptions<FnReturn>): Promise<FnReturn>;
//#endregion
//#region src/control-flows/sleep.d.ts
/**
 * @author fxhash <dev@fxhash.xyz>
 * @license MIT
 *
 * Control commands.
 */
/**
 * Returns a promise which resolves after given time.
 * @param ms The number of milliseconds
 */
declare function sleep(ms: number): Promise<void>;
//#endregion
//#region src/control-flows/timeout.d.ts
type SetIntervalCappedOptions = {
  /**
   * The time, in milliseconds, the timer should delay in between executions of
   * the specified function or code.
   * @default 0
   */
  delay: number;
  /**
   * Maximum number of steps before the setInterval resolves.
   * @default 20
   */
  maxSteps: number;
};
type IntervalFnReturnType = true | void;
type IntervalFn = () => Promise<IntervalFnReturnType> | IntervalFnReturnType;
/**
 * fn() will be called on every interval, until a max number of steps is reached
 * or fn() returns true.
 * @param fn A function which returns true or void. If true is returned, the
 * interval will be stopped.
 * @param param1 Options
 */
declare function setIntervalCapped(fn: IntervalFn, {
  delay,
  maxSteps
}: SetIntervalCappedOptions): Promise<void>;
//#endregion
//#region src/functions.d.ts
/**
 * A singleton wrapper for functionnal programming. The function passed will
 * only be called once the first time the singleton is called, then the same
 * reference will be returned.
 *
 * @param generator A function which instanciates some object
 * @param warning Whether a console.warning with the given value should be
 * emitted when there's already an instance.
 *
 * @returns A function which will return an existing instance or call the
 * generator to instanciate object.
 *
 * @example
 *
 * ```ts
 * const Singleton = singleton((a: string) => {
 *   let rnd = Math.random()
 *   console.log(a)
 *   return {
 *     rnd,
 *   }
 * })
 *
 * const callA = Singleton("hello") // log "hello"
 * const callB = Singleton("world") // log "world"
 * callA.rnd === callB.rnd // true
 * ```
 */
declare function singleton<T, U extends unknown[]>(generator: (...args: U) => T, warning?: string): (...args: U) => T;
//#endregion
//#region src/fetch.d.ts
type StopConditionType = (tryIdx: number) => boolean;
/**
 * Fetch with some retries
 * @param url the URL to fetch
 * @param maxRetries maximum number of retries before giving up, and throwing an error
 * @param delay time between each call (waits for the end of previous call)
 * @param stopCondition a function which will be called before each iteration, if it returns false, it stops
 * @returns
 */
declare const fetchRetry: (url: string, maxRetries?: number, delay?: number, shouldStop?: StopConditionType, timeout?: number | false) => Promise<Response>;
interface FetchOptions extends RequestInit {
  retries?: number;
  initialDelayMs?: number;
  shouldWaitBeforeRetry?: (error: any) => boolean;
  factor?: number;
  randomizationFactor?: number;
  maxDelayMs?: number;
}
declare const isRateLimitError: (error: any) => boolean;
/**
 * This function tries to fetch a url, and if it fails, waits an exponentially
 * increasing amount of time before trying again, until a maximum number of
 * retries have been reached.
 */
declare const fetchExponentialBackoff: (url: string, options?: FetchOptions) => Promise<Response>;
//#endregion
//#region src/float.d.ts
/**
 * Converts a floating-point number to its hexadecimal representation.
 *
 * This function takes a number (float or double) and returns its IEEE 754
 * double-precision floating-point representation as a hexadecimal string.
 *
 * @param n - The floating-point number to convert.
 * @returns A string representing the hexadecimal value of the input number.
 *          The string is 16 characters long, representing 8 bytes (64 bits)
 *          of the double-precision floating-point number.
 *
 * @example
 * console.log(float2hex(3.14159));
 * // Output: "400921fb54442d18"
 *
 * @remarks
 * - The function uses a DataView to handle the binary representation
 *   of the number.
 * - The resulting string is in big-endian order.
 * - This function works for both positive and negative numbers, including special
 *   values like Infinity, -Infinity, and NaN.
 */
declare function float2hex(n: number): string;
//#endregion
//#region src/network.d.ts
interface RetryOptions {
  maxAttempts?: number;
  initialDelay?: number;
  maxDelay?: number;
  factor?: number;
  jitter?: number;
}
declare function withExponentialBackoff<T>(operation: () => Promise<T>, options?: RetryOptions): Promise<T>;
//#endregion
//#region src/constants.d.ts
/**
 * A string composed of all the base 58 encoding scheme characters, in the right
 * order.
 */
declare const BASE58_CHARSET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
//#endregion
export { AtLeastOne, BASE58_CHARSET, DeepOmit, DeepPartial, Either, EventEmitter, Failure, FetchOptions, HashParams, IEquatableError, IEventEmitter, IRetryOptions, Init, Initialization, InitializationError, InvariantError, NonNullableFields, PromiseResult, RandFunction, ResettableRandFunction, Result, SetIntervalCappedOptions, Success, TArrayCompareFn, TArrayCopyFn, TSplitsTransformer, _Key, arrayIndexOf, arrayRemove, arrayRemoveDuplicates, assertFailure, assertSuccess, b58checkHexString, bytesToString, capitalize, cleanup, createFxRandom, enumKeys, failure, fetchExponentialBackoff, fetchRetry, float2hex, getBlockchainFromAddress, getBlockchainFromTransactionHash, getRandomHash, initOnce, intialization, invariant, isBaseAddressValid, isBaseTransactionHashValid, isBlockchainAddressValid, isEthereumAddressValid, isEthereumTransactionHashValid, isRateLimitError, isTezosAddressValid, isTezosTransactionHashValid, isTransactionHashValid, mockBaseAddress, mockBaseTransactionHash, mockBlockchainAddress, mockEthereumAddress, mockEthereumTransactionHash, mockTezosAddress, mockTezosTransactionHash, mockTransactionHash, nonNullable, parseHashParams, retriable, retry, setIntervalCapped, singleton, sleep, splitStringAt, stringToByteString, success, tagsFromString, transformSplitsAccessList, transformSplitsEqual, transformSplitsSum100, transformSplitsSum1000, truncateMiddle, u8hex, uniqueId, withExponentialBackoff, xorshift64, xorshiftString };
//# sourceMappingURL=index.d.ts.map