import { BASE58_CHARSET } from "./constants-preV6l4A.js";
import { getBlockchainFromAddress, isBaseAddressValid, isBlockchainAddressValid, isEthereumAddressValid, isTezosAddressValid, mockBaseAddress, mockBlockchainAddress, mockEthereumAddress, mockTezosAddress } from "./address-fy1FeLWD.js";
import { getBlockchainFromTransactionHash, isBaseTransactionHashValid, isEthereumTransactionHashValid, isTezosTransactionHashValid, isTransactionHashValid, mockBaseTransactionHash, mockEthereumTransactionHash, mockTezosTransactionHash, mockTransactionHash } from "./hash-DpgZuvgv.js";
import { createFxRandom, getRandomHash } from "./math-CJgeBN_r.js";
import { parseHashParams } from "./url-PF53DtLt.js";
import bs58check from "bs58check";

//#region src/base58.ts
/**
* OP_PREFIX: Tezos operation prefix
* 5 (0x05) represents the generic operation tag
* 116 (0x74) is the operation kind tag for transactions
* This prefix is used to identify Tezos operations in the network
*/
const OP_PREFIX = new Uint8Array([5, 116]);
/**
* Encodes a 32 bytes hex string with base58check, and pads the output with
* an initial information byte "o", just like Tezos operations.
* @param hex input 32 bytes hex string to encode
*/
function b58checkHexString(hex) {
	const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
	const hexBuffer = new Uint8Array(cleanHex.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));
	const fullBuffer = new Uint8Array(OP_PREFIX.length + hexBuffer.length);
	fullBuffer.set(OP_PREFIX);
	fullBuffer.set(hexBuffer, OP_PREFIX.length);
	const encoded = bs58check.encode(fullBuffer);
	return "o" + encoded;
}

//#endregion
//#region src/bytes.ts
/**
* Very quick string hashing algorithm where each character is passed through
* some xorshift variant to produce some 64bit hash represented as a number.
* Can be useful when there is a need to derive some unique ID for unique
* strings in a fast way.
*
* @param str A string as input
*
* @returns A hash as a 64bit number for faster processing
*
* @example
* ```ts
* const hash = xorshiftString("hello world") // 7d2fb77d
* const hash = xorshiftString("hey")          // 216e3ffa
* const hash = xorshiftString("a")            // 704e3821
* const hash = xorshiftString("b")            // 4e37a71e
* ```
*/
function xorshiftString(str) {
	let x = 0;
	for (let i = 0; i < str.length; i++) {
		const c = str.charCodeAt(i);
		x ^= c;
		x ^= x << 13;
		x ^= x >> 7;
		x ^= x << 17;
	}
	return x;
}
/**
* Computes a 64bit hash (returned as a number) for any serializable value
* passed. The value must be serializable using `JSON.stringify()` otherwise
* this function throws.
*
* Under the hood, does `xorshiftString(JSON.stringify(serializable))`
*
* @param serializable A value which can be serialized with `JSON.stringify()`
*
* @returns A 64bit hash as a number
*
* @example
* ```ts
* const hash = xorshift64({ some: "value", numb: 2 }) // 7e34a2b7
* ```
*/
function xorshift64(serializable) {
	return xorshiftString(JSON.stringify(serializable));
}

//#endregion
//#region src/uint8.ts
/**
* Outputs the lowercase hex string representation of a Uint8Array
* @param uint8 A sequence of bytes to convert
* @returns The lowercase hex string representation of the Uint8Array
*
* @example
*
* const arr = new Uint8Array(255, 0, 128, 0, 128, 255)
* const hex = uint8(arr) // "ff00800080ff"
*/
function u8hex(uint8) {
	return [...uint8].map((x) => x.toString(16).padStart(2, "0")).join("");
}

//#endregion
//#region src/string.ts
/**
* Turn the first character of a string into an UPPERCASE letter.
* @param str String to capitalize
* @returns Capitalized string
*
* @example
*
* capitalize("abcde") // "Abcde"
*/
function capitalize(str) {
	if (!str) return "";
	return str.charAt(0).toUpperCase() + str.slice(1);
}
function truncateMiddle(str, length, ellipsis = "...") {
	if (length * 2 >= str.length) return str;
	const start = str.slice(0, length);
	const end = str.slice(-length);
	return `${start}${ellipsis}${end}`;
}
/**
* Generates a *unique* string ID, using `Date.now()` and `Math.random()`. IDs
* may not have the same length.
*
* **Warning: not cryptographically secure!**
*
* @returns A *unique* string ID
*/
function uniqueId() {
	return Date.now().toString(36) + Math.random().toString(36).slice(2);
}
/**
* Splits a string in 2 sections at a given index, and returns these 2 sections.
*/
function splitStringAt(str, index) {
	return [str.slice(0, index), str.slice(index)];
}
/**
* convert a string of tags separated by commas into an array of tags
* @param str String of tags separated by commas
* @returns Array\<string> of tags
*/
function tagsFromString(str) {
	return str.split(",").map((tag) => tag.trim()).filter((tag) => tag.length > 0);
}
/**
* convert an array of bytes into a string
* @param byteArray Array of numbers to
* @returns String
*/
function bytesToString(byteArray) {
	return Array.from(byteArray, function(byte) {
		return ("0" + (byte & 255).toString(16)).slice(-2);
	}).join("");
}
/**
* convert string to byte string
* @param str String to convert
* @returns Byte string
*/
function stringToByteString(str) {
	const bytes = [];
	for (let i = 0; i < str.length; i++) bytes.push(str.charCodeAt(i));
	return bytesToString(bytes);
}

//#endregion
//#region src/types/errors.ts
/**
* An error that occurs when a task violates a logical condition that is assumed to be true at all times.
*/
var InvariantError = class extends Error {
	name = "InvariantError";
};
/**
* Asserts that the given condition is truthy
*
* @param condition - Either truthy or falsy value
* @param message - An error message
*/
function invariant(condition, message) {
	if (!condition) throw new InvariantError(message);
}

//#endregion
//#region src/types/result.ts
/**
* A `Success<T, E>` represents a successful computation that returns a value of type `T`.
*
* `E` in `Success<T, E>` is the type of the error that would have been returned in case of failure.
* It's present only to allow type safety of the `isFailure` method.
*
* @sealed
* @privateRemarks DO NOT EXPORT, see type export later on
* @typeParam T - the success value type
*/
var Success = class {
	/** @internal */
	constructor(value) {
		this.value = value;
	}
	isSuccess() {
		return true;
	}
	isFailure() {
		return false;
	}
	unwrap() {
		return this.value;
	}
};
/**
* A `Success<T, E>` represents a successful computation that returns a value of type `T`.
*
* `T` in `Failure<T, E>` is the type of the value that would have been returned in case of success.
* It's present only to allow type safety of the `isSuccess` method.
*
* @sealed
* @privateRemarks DO NOT EXPORT, see type export later on
* @typeParam E - the failure error type
*/
var Failure = class {
	/** @internal */
	constructor(error) {
		this.error = error;
	}
	isSuccess() {
		return false;
	}
	isFailure() {
		return true;
	}
	unwrap() {
		throw this.error;
	}
};
function success(value = void 0) {
	return new Success(value);
}
/**
* @internal
*/
const failure = (error) => new Failure(error);
/**
* Ensures the `Result<T, E>` is a `Success<T>`.
*/
function assertSuccess(result) {
	invariant(result.isSuccess(), "Expected a success result");
}
/**
* Ensures the `Result<T, E>` is a `Failure<E>`.
*/
function assertFailure(result) {
	invariant(result.isFailure(), "Expected a failure result");
}

//#endregion
//#region src/types/enums.ts
/**
* Returns a typed array of every enum properties there is in the enum.
* @param obj An enum object
* @returns An array of every enum properties
*/
function enumKeys(obj) {
	return Object.keys(obj).filter((k) => !Number.isNaN(k));
}

//#endregion
//#region src/array.ts
function arrayRemove(array, par2, onlyOnce = false) {
	if (typeof par2 === "function") {
		const test = par2;
		for (let i = array.length - 1; i >= 0; i--) if (test(array[i])) {
			array.splice(i, 1);
			if (onlyOnce) break;
		}
	} else {
		const idx = array.indexOf(par2);
		if (idx > -1) array.splice(idx, 1);
	}
	return array;
}
/**
* Returns the array position (0-based) of an element in an array, tested using
* a test function. If the test function returns true for an element in the
* array, its index will be returned. Array is parsed from left to right.
*
* @returns Index of the element or -1 if not in the array
*/
function arrayIndexOf(arr, test) {
	let idx = -1;
	for (let i = 0; i < arr.length; i++) if (test(arr[i])) {
		idx = i;
		break;
	}
	return idx;
}
function arrayRemoveDuplicates(array, isSame = (a, b) => a === b, arrayCopy = (arr) => arr) {
	const ret = arrayCopy(array);
	for1: for (let i = array.length - 1; i >= 1; i--) for (let j = i - 1; j >= 0; j--) if (isSame(array[i], array[j])) {
		ret.splice(i, 1);
		continue for1;
	}
	return ret;
}

//#endregion
//#region src/splits.ts
const transformSplitsEqual = (splits) => {
	return Math.floor(1e3 / splits.length);
};
const transformSplitsSum1000 = (splits, index) => {
	return Math.floor(1e3 / splits.length) + (index < 1e3 % splits.length ? 1 : 0);
};
const transformSplitsSum100 = (splits, index) => {
	return Math.floor(100 / splits.length) + (index < 100 % splits.length ? 1 : 0);
};
const transformSplitsAccessList = (splits, index) => {
	return splits[index].pct;
};

//#endregion
//#region src/events.ts
/**
* A simple EventEmitter class, in the spirit of NodeJS EventEmitter & browser
* APIs EventTarget. Supports `await this.emit(...)`.
*/
var EventEmitter = class {
	_listeners = {};
	_muted = {};
	_only = null;
	/**
	* Attach a listener on event of given name.
	* @param name Event name
	* @param fn Listener
	* @returns A function which can be used to remove the event listener which
	* was just set.
	*/
	on(name, fn) {
		if (!this._listeners.hasOwnProperty(name)) this._listeners[name] = [];
		this._listeners[name].push(fn);
		return () => this.off(name, fn);
	}
	/**
	* Detach a listener on event of given name. If such listener isn't attached
	* anymore, nothing happens. If the same listener was somehow registered
	* multiple times, they will all be removed. An equality check is made on
	* the listener function.
	* @param name Event name
	* @param fn Listener to remove
	*/
	off(name, fn) {
		const currentListeners = this._listeners[name];
		if (!currentListeners) return;
		const listeners = [];
		for (let i = 0, length = currentListeners.length; i < length; i++) if (currentListeners[i] !== fn) listeners.push(currentListeners[i]);
		this._listeners[name] = listeners;
	}
	/**
	* Immediately call all the listeners on event of given name, and resolves
	* once all the listeners have resolved.
	*
	* @param name Event name to dispatch
	* @param payload Payload to dispatch
	*/
	async emit(name, ...[payload]) {
		if (this._only && !this._only.includes(name)) return;
		if (this._muted[name]) return;
		const listeners = this._listeners[name];
		if (!listeners) return;
		await Promise.allSettled(listeners.map((listener) => Promise.resolve(listener(payload))));
	}
	/**
	* Forwards all the events of a given `name` emitted by this emitter to a
	* target `emitter`. Whenever this emitter will emit `name`, the target
	* `emitter` will also emit `name` with the same payload.
	* @param name Event name
	* @param emitter Target Event Emitter which should emit the same event when
	* this emitter emits it.
	* @returns A function to clear the pipe.
	*/
	pipe(name, emitter) {
		return this.on(name, (payload) => emitter.emit(name, payload));
	}
	/**
	* Mute/Unmute a particular event of the Event Emitter. If muted, no event of
	* such kind will be emitted when the `emit()` method is called.
	* @param event Event key to be muted
	* @param muted Whether the emitter should be muted or not
	*/
	mute(event, muted = true) {
		this._muted[event] = muted;
		return this;
	}
	/**
	* Restricts this Event Emitter from only emitting a given list of events. Any
	* other event will be ignored. This overrides the `mute(true)` option for an
	* event (an event which was explicitely set to `mute(evt, true)` will not
	* pass if it's not part of the array provided to this function).
	*
	* @param events A list of the only events which can be emitted
	*/
	only(...events) {
		this._only = events;
		return this;
	}
};

//#endregion
//#region src/control-flows/cleanup.ts
/**
* Simple cleanup utility.
*
* @example
*
* ```ts
* const clean = cleanup()
* //...
* clean.add(
*   () => document.removeEventListener("click", clickHandler),
*   () => document.removeEventListener("mousemove", mouseHandler),
* )
* //...
* clean.clear()
* ```
*/
function cleanup() {
	const _toClean = [];
	return {
		add: (...cleaners) => _toClean.push(...cleaners),
		clear: () => {
			_toClean.forEach((fn) => fn());
			_toClean.length = 0;
		}
	};
}

//#endregion
//#region src/control-flows/initialization.ts
let Init = /* @__PURE__ */ function(Init$1) {
	Init$1["NOT_STARTED"] = "NOT_STARTED";
	Init$1["STARTED"] = "STARTED";
	Init$1["FINISHED"] = "FINISHED";
	Init$1["FAILED"] = "FAILED";
	return Init$1;
}({});
const initStartErrorMessage = {
	[Init.STARTED]: `Initialization already in process`,
	[Init.FINISHED]: `Already been intialized`,
	[Init.FAILED]: `Already failed`
};
const initFinishErrorMessage = {
	[Init.NOT_STARTED]: `Initialization cannot finish if it has not started`,
	[Init.FINISHED]: `Initialization has already finished`,
	[Init.FAILED]: `Already failed`
};
/**
* An utility initialization module for handling async initializations which can
* only be done once.
*
* @example
*
* ```ts
* class Something {
*   private _init = initialization()
*
*   public async init() {
*     this._init.start() // will throw if already started
*     // ... some async stuff ...
*     this._init.finish()
*   }
*
*   public requiresInit() {
*     this._init.check("not finished") // throws if not finished
*   }
* }
* ```
*/
function intialization() {
	let state = Init.NOT_STARTED;
	let failReason;
	return {
		get state() {
			return state;
		},
		get finished() {
			return state === Init.FINISHED;
		},
		failed() {
			return state === Init.FAILED;
		},
		fail(reason) {
			invariant(reason, "a fail reason must be provided");
			state = Init.FAILED;
			failReason = new InitializationError(reason);
			return failReason;
		},
		get failReason() {
			return failReason;
		},
		check(message) {
			if (state === Init.FAILED) throw failReason;
			invariant(state === Init.FINISHED, message || "Initialization not finished");
		},
		start(message) {
			invariant(state === Init.NOT_STARTED, message || initStartErrorMessage[state]);
			state = Init.STARTED;
		},
		finish(message) {
			invariant(state === Init.STARTED, message || initFinishErrorMessage[state]);
			state = Init.FINISHED;
		}
	};
}
var UnknownError = class extends Error {
	name = "UnknownError";
};
var InitializationError = class extends Error {
	name = "InitializationError";
	cause;
	constructor(cause) {
		super("InitializationError");
		this.cause = cause || new UnknownError();
	}
};
/**
* @example
*
* ```ts
* const init = initialization()
* const initFn = initOnce(init, async () => {
*   // do async tasks...
* })
* await initOnce() // ok
* await initOnce() // throws
* ```
*/
function initOnce(init, fn) {
	return async () => {
		try {
			init.start();
			await fn();
			init.finish();
		} catch (err) {
			throw init.fail(err);
		}
	};
}

//#endregion
//#region src/control-flows/nullish.ts
/**
* Check if `x` is not null or undefined. If not, narrows `x` type with a
* `NonNullable<x>` predicate.
* @param x The variable to test
* @returns A boolean which indicates whether `x` is nullable or not
*/
function nonNullable(x) {
	return typeof x !== "undefined" && x !== null;
}

//#endregion
//#region src/control-flows/retry.ts
/**
* Decorates an async function with `retry()`: the function will be callable in
* the same fashion as it was, but will have a retry mechanism implemented. This
* function internally calls `retry()` from this same package.
*
* @param fn An async function
* @param options Retry options
*
* @returns A function which will automatically retry until fn() resolves, or
* `maxRetries` have been reached.
* @throws When `maxRetries` have been reached
*/
function retriable(fn, options = {}) {
	return async (...params) => {
		return retry(() => fn(...params), options);
	};
}
/**
* Retries to run an async function until it resolves (in which case this
* function resolves with sudhc value) or until maxRetries have been attempted,
* in which case this function throws with either the last error throws by the
* function or `MaxRetriesError` if the function has always timeout.
*
* @param fn A function which returns a promise, which will be retried until it
* resolves (or until maxRetries have been reached)
* @param options Retry options
*
* @returns The promise resolve value.
* @throws When maxRetries have been reached with either the last error thrown
* by the fn, or MaxRetriesError if every call has timeout.
*/
async function retry(fn, options = {}) {
	const { maxRetries = 3, interval = 1e3, timeout, onRetry, shouldRetryOnSuccess } = options;
	let retries = 0, start, fnError = null;
	while (retries <= maxRetries) {
		retries > 0 && onRetry?.(retries);
		start = performance.now();
		const promises = [fn()];
		if (typeof timeout !== "undefined") promises.push((async () => {
			await sleep(timeout);
			throw new TimeoutError();
		})());
		try {
			const res = await Promise.race(promises);
			if (shouldRetryOnSuccess?.(res)) {} else return res;
		} catch (err) {
			if (!(err instanceof TimeoutError)) fnError = err;
		}
		const duration = performance.now() - start;
		const effectiveInterval = interval - duration;
		if (effectiveInterval > 0) await sleep(effectiveInterval);
		retries++;
	}
	throw fnError || new MaxRetriesError();
}
var TimeoutError = class extends Error {
	name = "TimeoutError";
};
var MaxRetriesError = class extends Error {
	name = "MaxRetriesError";
};

//#endregion
//#region src/control-flows/sleep.ts
/**
* @author fxhash <dev@fxhash.xyz>
* @license MIT
*
* Control commands.
*/
/**
* Returns a promise which resolves after given time.
* @param ms The number of milliseconds
*/
function sleep(ms) {
	return new Promise((resolve) => setTimeout(resolve, ms));
}

//#endregion
//#region src/control-flows/timeout.ts
/**
* fn() will be called on every interval, until a max number of steps is reached
* or fn() returns true.
* @param fn A function which returns true or void. If true is returned, the
* interval will be stopped.
* @param param1 Options
*/
async function setIntervalCapped(fn, { delay = 0, maxSteps = 20 }) {
	for (let i = 0; i < maxSteps; i++) {
		if (await Promise.resolve(fn()) === true) return;
		await sleep(delay);
	}
}

//#endregion
//#region src/functions.ts
/**
* A singleton wrapper for functionnal programming. The function passed will
* only be called once the first time the singleton is called, then the same
* reference will be returned.
*
* @param generator A function which instanciates some object
* @param warning Whether a console.warning with the given value should be
* emitted when there's already an instance.
*
* @returns A function which will return an existing instance or call the
* generator to instanciate object.
*
* @example
*
* ```ts
* const Singleton = singleton((a: string) => {
*   let rnd = Math.random()
*   console.log(a)
*   return {
*     rnd,
*   }
* })
*
* const callA = Singleton("hello") // log "hello"
* const callB = Singleton("world") // log "world"
* callA.rnd === callB.rnd // true
* ```
*/
function singleton(generator, warning) {
	const instance = null;
	return (...args) => {
		if (instance) {
			if (warning) console.warn(warning);
			return instance;
		}
		return generator(...args);
	};
}

//#endregion
//#region src/fetch.ts
/**
* Fetch with some retries
* @param url the URL to fetch
* @param maxRetries maximum number of retries before giving up, and throwing an error
* @param delay time between each call (waits for the end of previous call)
* @param stopCondition a function which will be called before each iteration, if it returns false, it stops
* @returns
*/
const fetchRetry = async (url, maxRetries = 5, delay = 200, shouldStop = () => false, timeout = false) => {
	let error;
	for (let i = 0; i < maxRetries; i++) {
		if (shouldStop(i)) break;
		try {
			const controller = new AbortController();
			if (timeout !== false) setTimeout(() => controller.abort(), timeout);
			const data = await fetch(url, { signal: controller.signal });
			if (data.status === 404) throw "404";
			return data;
		} catch (err) {
			error = err;
		}
		await sleep(delay);
	}
	throw error;
};
const isRateLimitError = (error) => {
	const TOO_MANY_REQUESTS = 429;
	return error.status === TOO_MANY_REQUESTS;
};
const OK_STATUSES = new Set([
	200,
	201,
	202,
	203,
	204,
	205,
	206
]);
/**
* This function tries to fetch a url, and if it fails, waits an exponentially
* increasing amount of time before trying again, until a maximum number of
* retries have been reached.
*/
const fetchExponentialBackoff = async (url, options = {}) => {
	const { retries = 5, initialDelayMs = 2e3, shouldWaitBeforeRetry = isRateLimitError, factor = 2, randomizationFactor = .5, maxDelayMs = 6e4,...fetchOptions } = options;
	let currentDelay = initialDelayMs;
	for (let attempt = 0; attempt <= retries; attempt++) try {
		const response = await fetch(url, fetchOptions);
		if (!OK_STATUSES.has(response.status)) throw response;
		return response;
	} catch (error) {
		if (attempt === retries) throw error;
		if (shouldWaitBeforeRetry(error)) {
			const jitter = 1 + randomizationFactor * (Math.random() * 2 - 1);
			const delay = Math.min(currentDelay * jitter, maxDelayMs);
			await sleep(delay);
			currentDelay = Math.min(currentDelay * factor, maxDelayMs);
		}
	}
	throw new Error("Maximum retries reached");
};

//#endregion
//#region src/float.ts
/**
* Converts a floating-point number to its hexadecimal representation.
*
* This function takes a number (float or double) and returns its IEEE 754
* double-precision floating-point representation as a hexadecimal string.
*
* @param n - The floating-point number to convert.
* @returns A string representing the hexadecimal value of the input number.
*          The string is 16 characters long, representing 8 bytes (64 bits)
*          of the double-precision floating-point number.
*
* @example
* console.log(float2hex(3.14159));
* // Output: "400921fb54442d18"
*
* @remarks
* - The function uses a DataView to handle the binary representation
*   of the number.
* - The resulting string is in big-endian order.
* - This function works for both positive and negative numbers, including special
*   values like Infinity, -Infinity, and NaN.
*/
function float2hex(n) {
	const getHex = (i) => i.toString(16).padStart(2, "0");
	const view = new DataView(new ArrayBuffer(8));
	view.setFloat64(0, n);
	return [...Array(8)].map((_, i) => getHex(view.getUint8(i))).join("");
}

//#endregion
//#region src/network.ts
const DEFAULT_RETRY_OPTIONS = {
	maxAttempts: 5,
	initialDelay: 500,
	maxDelay: 32e3,
	factor: 2,
	jitter: .1
};
async function withExponentialBackoff(operation, options = {}) {
	const opts = {
		...DEFAULT_RETRY_OPTIONS,
		...options
	};
	let attempt = 1;
	let delay = opts.initialDelay;
	while (true) try {
		return await operation();
	} catch (error) {
		if (attempt >= opts.maxAttempts) throw error;
		const jitterAmount = delay * opts.jitter;
		const actualDelay = delay + (Math.random() * 2 - 1) * jitterAmount;
		await new Promise((resolve) => setTimeout(resolve, actualDelay));
		delay = Math.min(delay * opts.factor, opts.maxDelay);
		attempt++;
	}
}

//#endregion
export { BASE58_CHARSET, EventEmitter, Failure, Init, InitializationError, InvariantError, Success, arrayIndexOf, arrayRemove, arrayRemoveDuplicates, assertFailure, assertSuccess, b58checkHexString, bytesToString, capitalize, cleanup, createFxRandom, enumKeys, failure, fetchExponentialBackoff, fetchRetry, float2hex, getBlockchainFromAddress, getBlockchainFromTransactionHash, getRandomHash, initOnce, intialization, invariant, isBaseAddressValid, isBaseTransactionHashValid, isBlockchainAddressValid, isEthereumAddressValid, isEthereumTransactionHashValid, isRateLimitError, isTezosAddressValid, isTezosTransactionHashValid, isTransactionHashValid, mockBaseAddress, mockBaseTransactionHash, mockBlockchainAddress, mockEthereumAddress, mockEthereumTransactionHash, mockTezosAddress, mockTezosTransactionHash, mockTransactionHash, nonNullable, parseHashParams, retriable, retry, setIntervalCapped, singleton, sleep, splitStringAt, stringToByteString, success, tagsFromString, transformSplitsAccessList, transformSplitsEqual, transformSplitsSum100, transformSplitsSum1000, truncateMiddle, u8hex, uniqueId, withExponentialBackoff, xorshift64, xorshiftString };
//# sourceMappingURL=index.js.map