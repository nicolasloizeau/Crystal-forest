import { BASE58_CHARSET } from "./constants-preV6l4A.js";

//#region src/address.ts
function mockEthereumAddress() {
	const randomBytes = Array.from({ length: 20 }, () => Math.random() * 256 | 0);
	const hexString = Array.from(randomBytes).map((byte) => byte.toString(16).padStart(2, "0")).join("");
	return `0x${hexString}`;
}
const mockBaseAddress = mockEthereumAddress;
function mockTezosAddress() {
	const randomSequence = Array.from({ length: 33 }, () => BASE58_CHARSET[Math.random() * BASE58_CHARSET.length | 0]).join("");
	return `tz1${randomSequence}`;
}
function mockBlockchainAddress(chain) {
	if (["ETHEREUM", "BASE"].includes(chain)) return mockEthereumAddress();
	return mockTezosAddress();
}
function isTezosAddressValid(address) {
	if (address.length !== 36) return false;
	if (!/^(tz|KT)[1-4]/.test(address)) return false;
	for (let i = 0; i < address.length; i++) if (!BASE58_CHARSET.includes(address[i])) return false;
	return true;
}
function isEthereumAddressValid(address) {
	return /^(0x)?[0-9a-fA-F]{40}$/.test(address);
}
const isBaseAddressValid = isEthereumAddressValid;
function getBlockchainFromAddress(address) {
	if (isEthereumAddressValid(address)) return "ETHEREUM";
	if (isTezosAddressValid(address)) return "TEZOS";
	throw new Error("The provided address is not a valid tezos or ethereum address");
}
function isBlockchainAddressValid(address) {
	return [
		isTezosAddressValid,
		isEthereumAddressValid,
		isBaseAddressValid
	].some((validation) => validation(address));
}

//#endregion
export { getBlockchainFromAddress, isBaseAddressValid, isBlockchainAddressValid, isEthereumAddressValid, isTezosAddressValid, mockBaseAddress, mockBlockchainAddress, mockEthereumAddress, mockTezosAddress };
//# sourceMappingURL=address-fy1FeLWD.js.map